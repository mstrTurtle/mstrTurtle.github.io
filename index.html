<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>生活中的智慧</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="生活中的智慧">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="生活中的智慧">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="生活中的智慧" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">生活中的智慧</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-coroutine-revisit" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/12/coroutine-revisit/" class="article-date">
  <time class="dt-published" datetime="2023-01-12T15:32:24.645Z" itemprop="datePublished">2023-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/12/coroutine-revisit/">继续思考coroutine</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>20计科一班肖嘉裕:<br>不是的，猪猪在静坐</p>
<p>20计科一班肖嘉裕:<br>[笑哭]</p>
<p>20计科一班肖嘉裕:<br>正在冥想</p>
<p>20计科一班肖嘉裕:<br>并且猪猪貌似还真想出了点啥</p>
<p>20计科一班肖嘉裕:<br>[斜眼笑]</p>
<p>Mångata:<br>[笑哭]嗯嗯</p>
<p>Mångata:<br>比如呢[斜眼笑]</p>
<p>20计科一班肖嘉裕:<br>比如: 协程是怎么恢复上下文的</p>
<p>20计科一班肖嘉裕:<br>比如一个没有initial_suspend的东西, 外界是怎么获得handle, 让它恢复执行的呢</p>
<p>20计科一班肖嘉裕:<br>还有就是, co_return后, 发生了什么?</p>
<p>20计科一班肖嘉裕:</p>
<blockquote>
<p>还有就是, co_return后, 发生了什么?<br>这一点猪猪想明白了, 应该是编译器自动塞了些保存线程上下文的代码, 把活儿给干了</p>
</blockquote>
<p>20计科一班肖嘉裕:</p>
<blockquote>
<p>比如一个没有initial_suspend的东西, 外界是怎么获得handle, 让它恢复执行的呢<br>这点的话, 猪猪需要参考cppreference这个网站, 它有个生成器示例, 看看就知道handle在哪儿</p>
</blockquote>
<p>Mångata:<br>[兔子-哇]</p>
<p>20计科一班肖嘉裕:<br>猪猪看了看, 发现handle是编译器自动注入promise_type的</p>
<p>20计科一班肖嘉裕:<br>handle有promise, done, destory, operator(), 这四种方法</p>
<p>20计科一班肖嘉裕:<br>可以自由控制协程的启停, 查询协程的状态, 获取协程的promise_type</p>
<p>Mångata:<br>[奶龙-哇]</p>
<p>20计科一班肖嘉裕:<br>cppreference里的Generator(也就是promise_type), 暴露了一个函数. 此函数可以调用handle的operator(), 让协程继续运行(也就是踢协程一脚)</p>
<p>20计科一班肖嘉裕:<br>[斜眼笑]</p>
<p>20计科一班肖嘉裕:<br>这就是猪猪的全部思路啦</p>
<p>Mångata:<br>[奶龙-哇]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/12/coroutine-revisit/" data-id="clct926dx0000k0ju949mgq38" data-title="继续思考coroutine" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/11/hexo/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T16:21:47.179Z" itemprop="datePublished">2023-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/11/hexo/">Hexo怎么用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这些命令应该有所帮助:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo -h</span><br><span class="line">hexo d</span><br><span class="line">hexo g</span><br><span class="line">hexo d -g</span><br><span class="line"><span class="built_in">cat</span> (Get-PSReadlineOption).HistorySavePath | select-something hexo</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/11/hexo/" data-id="clcqfyx7e000138jubbh98da9" data-title="Hexo怎么用" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-haskell" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/11/haskell/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T16:18:36.886Z" itemprop="datePublished">2023-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/11/haskell/">Haskell配置笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>请注意: $PATH不要有win下的choco(cabal), 还有apt的ghc等等. 需要先清理干净.</p>
<h2 id="第一步-安装GHCUP"><a href="#第一步-安装GHCUP" class="headerlink" title="第一步, 安装GHCUP."></a>第一步, 安装GHCUP.</h2><p>(从官网上,找到curl安装脚本的链接.)</p>
<p>等它下完东西, ghcup就会出现在<del>&#x2F;.ghcup&#x2F;bin里面. 此时要在</del>&#x2F;.bashrc里重新export PATH&#x3D; $PATH:&#x2F;home&#x2F;turtle&#x2F;.ghcup&#x2F;bin.</p>
<p>装好后可以用tuna的hackage源, 把.cabal的config配置一下.</p>
<p>后续, 可以用ghcup tui, 把HLS之类的装上.</p>
<h2 id="第二步-创建cabal工程"><a href="#第二步-创建cabal工程" class="headerlink" title="第二步, 创建cabal工程."></a>第二步, 创建cabal工程.</h2><p>如: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir myvec &amp; cd myvec</span><br><span class="line">cabal init</span><br><span class="line">vim app/Main.hs</span><br><span class="line">vim app/Vec3.hs</span><br></pre></td></tr></table></figure>

<h2 id="第三步-显示指定hie-yaml"><a href="#第三步-显示指定hie-yaml" class="headerlink" title="第三步, 显示指定hie.yaml"></a>第三步, 显示指定hie.yaml</h2><p>根据<a target="_blank" rel="noopener" href="https://github.com/haskell/haskell-language-server/issues/2932">Multi Cradle: No prefixes </a><br>此issue, 不改hie.yaml, 就会:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Multi Cradle: No prefixes matched</span><br></pre></td></tr></table></figure>

<p>改法: </p>
<p>创建hie.yaml, 手动指定一些元信息. cabal留空, 因为它能自动推理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cradle:</span><br><span class="line">  cabal:</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cradle:</span><br><span class="line">  cabal:</span><br><span class="line">    - path: &quot;./src&quot;</span><br><span class="line">      component: &quot;exe:Main&quot;</span><br></pre></td></tr></table></figure>
<p>这样. 但这样太specific了. 不如上面自动推理</p>
<h2 id="第四步-改myvec-cabal"><a href="#第四步-改myvec-cabal" class="headerlink" title="第四步, 改myvec.cabal"></a>第四步, 改myvec.cabal</h2><p>受到<a target="_blank" rel="noopener" href="https://cabal.readthedocs.io/en/stable/cabal-package.html">6. Package Description</a>的启发:</p>
<p>把executable myvec加上<br><code>other-modules:    Vec3</code><br>这样你的Vec3.hs才是模块.否则就会</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">turtle@turtle:~/myvec$ cabal v2-repl /home/turtle/myvec/app/Vec3.hs</span><br><span class="line">cabal: Unknown target &#x27;/home/turtle/myvec/app/Vec3.hs&#x27;.</span><br><span class="line">The package myvec has no file target &#x27;app/Vec3.hs&#x27;.</span><br><span class="line"></span><br><span class="line">turtle@turtle:~/myvec$</span><br></pre></td></tr></table></figure>

<p>即:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Bug: `cabal repl file` fails for executable component</span><br></pre></td></tr></table></figure>

<h2 id="第五步-安装vscode-haskell插件"><a href="#第五步-安装vscode-haskell插件" class="headerlink" title="第五步, 安装vscode haskell插件"></a>第五步, 安装vscode haskell插件</h2><p>搜索安装插件,并且在settings.json里加上:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;haskell.manageHLS&quot;: &quot;GHCup&quot;,</span><br><span class="line">&quot;haskell.toolchain&quot;: &#123;</span><br><span class="line">    &quot;ghc&quot;: &quot;9.2.5&quot;,</span><br><span class="line">    &quot;hls&quot;: &quot;1.9.0.0&quot;,</span><br><span class="line">    &quot;cabal&quot;: &quot;recommended&quot;,</span><br><span class="line">    &quot;stack&quot;: null</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这些东西. 反正GHCup是可以在UI设置里调, 而且是必须调的(?)<br>而这个toolchain要不要调, 就不知道了. 照理说是按照cabal配置自动认的.</p>
<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>我手动编译了一个hls版本, 不知道有无影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghcup compile hls -v 1.9.0.0 --ghc 9.2.5</span><br></pre></td></tr></table></figure>

<p>编译它的动机是, 它总是说我用的ghc 8.6.5, 与它(hls)编译使用的ghc版本对不上.<br>我就手动编译了, 发现我使用的ghc还是8.6.5.</p>
<p>我就发现是apt的ghc, 在path里优先级较高, 导致它找apt的旧版本ghc去了.<br>而ghcup二进制下载来的prebuilt的hls, 版本貌似是对得上9.2.5的.<br>所以这个hls是白编译了.编译了挺久的, 大概1h.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/11/haskell/" data-id="clcqfyx78000038jugp0sdck1" data-title="Haskell配置笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-coroutine" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/13/coroutine/" class="article-date">
  <time class="dt-published" datetime="2022-12-12T17:11:48.120Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/13/coroutine/">coroutine解剖麻雀</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>20计科一班肖嘉裕:<br>The io_service class does not manage any I&#x2F;O threads. You must ensure that some thread calls one of the event-processing methods for coroutines awaiting I&#x2F;O completion events to be dispatched.</p>
<p>20计科一班肖嘉裕:<br>io_service类不管理任何IO线程. (所以)你必须保证, 让某些线程去调用那些事件处理方法(指io_service.process_events()那四个方法), 这样来让某些await IO completion event的协程得到执行.</p>
<p>20计科一班肖嘉裕:<br>大体意思就是: 进入了ioScope后, 那个协程就废了, 除非有某些线程, 去await process_events(), 来让出线程, 帮那个IO协程跑.<br>(2023-01-12评论: 这是错的. 它的意思是: io_service是寄生虫, 需要某个线程去调用io_service_process_events(), 它才会在此寄生线程上工作. 等io_context的工作做完, 函数才返回.)</p>
<p>20计科一班肖嘉裕:<br>这是出自cppcoro官方仓库README文档, io_service部分</p>
<p>20计科一班肖嘉裕:<br>它说, 可以跟UI线程整合. 我的理解是: UI线程上跑了很多个协程. 应该专门划分新IO线程, 专门给IO跑, 免得UI线程上放了个IO的协程, 导致其他很多UI协程都执行不了了.<br>(评论: 这是错的. 其实是这样理解: 如QT, 它每次事件循环, 会提供一个信号. 你可以创建槽函数, 槽里调用”io_context.poll_one_event()”, 再把此槽连接到那信号. 就完成了集成.)</p>
<p>请看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 这是计网实验(聊天室)的头文件. 这只是从GitHub的</span></span><br><span class="line"><span class="comment">// CoChat拷贝来的源码. 这是当时抄袭Stack Overflow所得到的</span></span><br><span class="line"><span class="comment">// 勉强能用的实现.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file co.hpp</span></span><br><span class="line"><span class="comment"> * @author turtle (qq769711153@hotmail.com)</span></span><br><span class="line"><span class="comment"> * @brief Header for Enabling C++20 Coroutine Support</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-06-18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Enable the use of std::future&lt;T&gt; as a coroutine type</span></span><br><span class="line"> <span class="comment">// by using a std::promise&lt;T&gt; as the promise type.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="built_in">requires</span>(!std::is_void_v&lt;T&gt; &amp;&amp; !std::is_reference_v&lt;T&gt;)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::coroutine_traits&lt;std::future&lt;T&gt;, Args...&gt; &#123;</span><br><span class="line">    <span class="comment">// future还不能作为coroutine type</span></span><br><span class="line">    <span class="comment">// 有两个解决办法: </span></span><br><span class="line">    <span class="comment">// 1. 新弄一个class, 里面需要定义struct promise_type(要么是内部类, 要么是typedef)</span></span><br><span class="line">    <span class="comment">// 2. 对于future&lt;T&gt;, 写一个coroutine_traits, 里面放一个promise_type, 好好进行指定.</span></span><br><span class="line">    <span class="comment">// 所以就有了这个东西.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> : std::promise&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 当你: auto a = fCoro();的时候, a就是丢给你这个东西的.</span></span><br><span class="line">        <span class="comment">// 本质上可以丢给你handle, 但这里, 是丢给你与promise伴随的future. promise是一个空箱子, </span></span><br><span class="line">        <span class="comment">// 只要你往里面塞一个值, 那么箱子里就有东西了. 对应的future就能get到东西了.</span></span><br><span class="line">        <span class="function">std::future&lt;T&gt; <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这很简单, 即调用fCoro()的时候, 里面该不该多暂停一次. 还有退出的时候该不该多暂停一次.</span></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这指定了co_return的行为. 从此处看来, 发生的事情是, promise被塞了东西(随之, 上述的伴随future也能get了)</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">            <span class="title">noexcept</span><span class="params">(std::is_nothrow_copy_constructible_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_value</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(T&amp;&amp; value)</span></span></span><br><span class="line"><span class="function">            <span class="title">noexcept</span><span class="params">(std::is_nothrow_move_constructible_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_value</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same for std::future&lt;void&gt;.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::coroutine_traits&lt;std::future&lt;<span class="type">void</span>&gt;, Args...&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> : std::promise&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow co_await&#x27;ing std::future&lt;T&gt; and std::future&lt;void&gt;</span></span><br><span class="line"><span class="comment">// by naively spawning a new thread for each co_await.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">(std::future&lt;T&gt; future)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    <span class="title">requires</span><span class="params">(!std::is_reference_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是指定co_await操作符的行为.可见这里指定的是, 操作数为future&lt;T&gt;时, 会发生什么</span></span><br><span class="line">    <span class="comment">// 总之, 操作符需要返回一个带有三个特殊方法(await_ready, await_suspend, await_resume)的类实例.</span></span><br><span class="line">    <span class="comment">// 运行的时候, 执行这个操作符之后, 会发生这样的事情:</span></span><br><span class="line">    <span class="comment">// 首先, 调用await_ready, 如果ready了, 直接调用await_resume, 否则, 就调用await_suspend(此时还会把handle塞给你).</span></span><br><span class="line">    <span class="comment">// 我的理解是: resume的话, coroutine在这个线程上继续跑. 否则(即suspend), 它就会让出当前线程, 并且handle.resume()在哪个线程执行,</span></span><br><span class="line">    <span class="comment">// coroutine就会在哪个线程上接着跑.</span></span><br><span class="line">    <span class="comment">// 剩下的, 运行时啥都不会干了. 所以全凭你往这三个函数里塞了什么.</span></span><br><span class="line">    <span class="comment">// 请看这个示例, 以下是执行的代码:</span></span><br><span class="line">    <span class="comment">// fa()&#123;</span></span><br><span class="line">    <span class="comment">//     x = await xx;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// fb()&#123;</span></span><br><span class="line">    <span class="comment">//     y = await yy;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// auto a = fa();</span></span><br><span class="line">    <span class="comment">// auto b = fb();</span></span><br><span class="line">    <span class="comment">// 同时, 在await操作符的配置中有:</span></span><br><span class="line">    <span class="comment">// await_suspend(handle)&#123;</span></span><br><span class="line">    <span class="comment">//     newthread([]&#123;</span></span><br><span class="line">    <span class="comment">//         handle(); // 即继续运行协程. 即又来到await_ready这里. 此时会ready, 接下来调用await_resume, </span></span><br><span class="line">    <span class="comment">//                   // 当此resume函数返回值后, 协程就又跑起来了.</span></span><br><span class="line">    <span class="comment">//     &#125;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 那么, 考虑上述那两段代码, 运行后会发生这些事情:</span></span><br><span class="line">    <span class="comment">// 现在, 在主线程上. 先执行fa(), 此时有coroutine_traits的promise_type配置, 它的get_return_object会随便给你些什么东西.</span></span><br><span class="line">    <span class="comment">// 现在, 主线程在跑fa了. 跑到await那行, 求值xx, 然后进入await操作符的函数. 它发现不ready, 得suspend. 于是进入awaiter的</span></span><br><span class="line">    <span class="comment">// suspend. 在这里, 我们开了个新线程, 然后用handle(), 踢了协程a一脚. 注意, handle是在新线程上执行的. 于是新线程上开始跑await_ready,</span></span><br><span class="line">    <span class="comment">// 此时ready了, 很好, 执行await_resume. resume函数返回了个值, 之后会赋给await左边的东西. 当resume函数返回完毕, 协程a也随之在新线程上</span></span><br><span class="line">    <span class="comment">// 继续跑了起来.</span></span><br><span class="line">    <span class="comment">// 而此时, 旧线程上, await_suspend成功返回. 那么现在旧线程已经没在跑别的东西了. 于是, 开始执行fb()又重复上述过程, 这下, 协程b也在另一个</span></span><br><span class="line">    <span class="comment">// 新线程上跑起来了.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">awaiter</span> : std::future&lt;T&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">wait_for</span>(<span class="number">0</span>s) != std::future_status::timeout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; cont)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 注意这里传入了handle</span></span><br><span class="line">            std::<span class="built_in">thread</span>([<span class="keyword">this</span>, cont] &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">cont</span>();</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> awaiter&#123; std::<span class="built_in">move</span>(future) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // Utilize the infrastructure we have established.</span></span><br><span class="line"><span class="comment">// std::future&lt;int&gt; compute(as_coroutine) &#123;</span></span><br><span class="line"><span class="comment">//     int a = co_await std::async([] &#123; std::cout &lt;&lt; &quot;six\n&quot;; return 6; &#125;);</span></span><br><span class="line"><span class="comment">//     int b = co_await std::async([] &#123; std::cout &lt;&lt; &quot;seven\n&quot;; return 7; &#125;);</span></span><br><span class="line"><span class="comment">//     co_return a * b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::future&lt;void&gt; fail(as_coroutine) &#123;</span></span><br><span class="line"><span class="comment">//     throw std::runtime_error(&quot;bleah&quot;);</span></span><br><span class="line"><span class="comment">//     co_return;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int tach() &#123;</span></span><br><span class="line"><span class="comment">//     auto fut = compute(&#123;&#125;);</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; fut.get();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/13/coroutine/" data-id="clbl203rw0000gkjuddlb3fxk" data-title="coroutine解剖麻雀" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-opengl" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/12/opengl/" class="article-date">
  <time class="dt-published" datetime="2022-12-12T07:47:35.105Z" itemprop="datePublished">2022-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/12/opengl/">OpenGL各种东西详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="glut-freeglut-glfw"><a href="#glut-freeglut-glfw" class="headerlink" title="glut, freeglut, glfw"></a>glut, freeglut, glfw</h1><ol>
<li>glut<ul>
<li>gl util tools</li>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘和鼠标事件</li>
<li>以一个函数呼叫绘制某些常用立体图形,如长方体,球,犹他茶壶</li>
<li>提供了简单选单列的实现</li>
</ul>
</li>
</ol>
<p>所有glut的库函数均已glut开头, 例如glutPostRedisplay(). 后来以及停止维护了</p>
<ol start="2">
<li><p>freeglut<br> glut的替代品,最新稳定的版本是Freeglut3.0.0 (2015年3月7日)</p>
</li>
<li><p>glfw</p>
<ul>
<li>gl framework</li>
<li>创建管理窗口和opengl的上下文</li>
<li>处理手柄,键盘,鼠标输入</li>
<li>目前glfw还在维护,可以说glfw库可以是代替glut和freeglut的库的</li>
</ul>
</li>
</ol>
<h1 id="glew-glad-gl3w"><a href="#glew-glad-gl3w" class="headerlink" title="glew, glad, gl3w"></a>glew, glad, gl3w</h1><p>opengl是一个标准&#x2F;规范, 具体的实现是由驱动开发商针对特定的显卡而实现.支持opengl的驱动版本众多,大多数函数的地址(内存地址)无法在编译时候确定下来,需要运行的时候查询.所以在运行的时候获取函数的内存地址并把其保存在一个函数指针中供后续使用. glew, glad, gl3w基本都是实现类似的功能</p>
<p>glew,<br>    opengl32.dll仅仅为用户提供了统一API的接口以及扩展这些接口的可能, opengl32.dll被加载后尝试调用更底层的ICD驱动程序,从而完成具体的图形操作. 而GLEW这些库,根据opengl的接口说明,从动态库(opengl32.dll)中请求对应的函数接口,如果能得到有效地址,那么这个函数是被当前驱动所支持的,就可以用,否则就无法支持.实际上,你也可以根据你当前应用中使用到的函数(通常一个小的演示demo,如显示一个三角形,并没有使用到很多的gl函数)而获取函数接口也是完全可行的. glew,glad,gl3w这些库帮助用户完成了所有接口的查询和获取.</p>
<p>glad,<br>gl3w</p>
<p>但是gl3w是利用python开发的, 因此需要安装python库进行编译生成相关的文件,具体的流程可以参考<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/jiuzaizuotian2014/article/details/82915917">基于GLFW和GL3W库的OPEN GL环境配置</a></p>
<p>结论: 可以用上面两类的库进行组合,例如我自己常用的是glfw + glad来进行opengl的开发, 也有很多开发者使用的是glfw + gl3w, 或者 glfw + glew</p>
<h1 id="另一篇说的"><a href="#另一篇说的" class="headerlink" title="另一篇说的"></a>另一篇说的</h1><p>opengl原生库?<strong>gl</strong></p>
<p>随opengl一起发布</p>
<p>opengl实用库?<strong>glu</strong><br>随opengl一起发布</p>
<p>opengl实用工具库glut?<strong>glut</strong><br>需要下载配置安装(太老了！)</p>
<p>opengl实用工具库开源版本freeglut?<strong>freeglut</strong><br>需要下载配置安装(完全兼容glut，算是glut的代替品，但是bug较多！)</p>
<p>opengl GLFW库?<strong>glfw</strong><br>需要下载配置安装(轻量级的，开源的，跨平台的library，新技术)</p>
<p>opengl GLEW库?<strong>glew</strong><br>需要下载配置安装<br>跨平台的C++扩展库，它的出现是为了方便的管理平台与opengl版本不匹配，以及方便的解决不同显卡特有的硬件接口支持。<br>只要包含一个glew.h头文件，你就能使用gl,glu,glext,wgl,glx的全部函数。</p>
<p>opengl核心文件加载库gl3w?<strong>gl3w</strong><br>gl3w是获取OpenGL核心配置文件规范所提供功能的最简单方法。</p>
<p>opengl库glad?<strong>glad</strong><br>基于官方规格的多语言GL &#x2F; GLES &#x2F; EGL &#x2F; GLX &#x2F; WGL装载机 - 生成器。<br>一般结合GLFW使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gl</td>
<td>核心库</td>
<td>随opengl一起发布. 貌似只是规范, 里面的函数只是签名, 没有链接?</td>
</tr>
<tr>
<td>glu</td>
<td>实用工具</td>
<td>随opengl一起发布</td>
</tr>
<tr>
<td>glut</td>
<td>很老的util</td>
<td>貌似是glfw+glew?20年没维护, 建议别用</td>
</tr>
<tr>
<td>freeglut</td>
<td>没那么老的util</td>
<td>glut继任者, 貌似也废了</td>
</tr>
<tr>
<td>glfw</td>
<td>靠谱的util, 即framework</td>
<td>帮你得到Window和OpenGL Rendering Context</td>
</tr>
<tr>
<td>glew</td>
<td>OpenGL Extension Wrangler</td>
<td>即,把显卡驱动里写好的dll嫁接到glew的函数指针上</td>
</tr>
<tr>
<td>gl3w</td>
<td>同上</td>
<td>这貌似用Python写的</td>
</tr>
<tr>
<td>glad</td>
<td>同上</td>
<td></td>
</tr>
</tbody></table>
<p>glfw is:</p>
<p><em>a library that helps you to manage such things as window, its size, params, basic input and events-stuff. GLEW needs a window and a valid OpenGL context to be setup, and that’s exactly where GLFW comes in handy.</em></p>
<p>glfw is:<br><em>Open source, portable framework for OpenGL application development with a link library for handling operating system specific tasks, such as opening an OpenGL window and reading keyboard, mouse and joystick input.</em></p>
<p>What is also interesting that these libraries were made not just to make your developing life easier, but also your <strong>deployment faster</strong>. GLEW and GLFW are kind of cross-platform so you don’t have to write different versions of the same application on different platforms.</p>
<p>As practice shows, GLEW&#x2F;GLAD + GLFW is a common use for modern computer graphics based on OpenGL. You?<em>could</em>, however, choose other libraries for a reason, based on what you need. But the general approach is to use these, because they support the latest versions of OpenGL, and always get updated.</p>
<p>EDIT</p>
<p>GLUT and GLFW are basically the same, but what you need to know is that the original GLUT has been unsupported for 20 years, and there is a free open-source alternative for it called freeglut. So, I guess that is what you mean by “deprecated” :)</p>
<p>COMMENT</p>
<p>GLFW purpose is to manage OpenGL contexts and basics of window-, keyboard-, event-handling. </p>
<p>It does not do automatic extension loading, so without a loader like glad, you can only use what the system provides on its own (which could also be the current version). </p>
<p>But you can load extensions&#x2F;functions manually using GLFW, so you indeed could use modern OpenGL using only GLFW.</p>
<p>COMMENT</p>
<p>OpenGL is already developed by the GPU manufacturers, saved as binary file in the graphics drive. </p>
<p>You can use it without any additional libraries. However, this would be complicated, especially for unexperienced developers. </p>
<p>For simplification, you can use any opengl loader library (<code>FreeGlut, Glad, Glew, GLUT</code>) + for windowing can use?<code>GLFW</code>. GLUT is often not recommended, and?<code>FreeGLUT</code>?and?<code>GLEW</code>?are widely used. You can use?<code>microsoft vcpkg</code>?to install these libraries.</p>
<h1 id="没glut-glew怎么套到现代函数"><a href="#没glut-glew怎么套到现代函数" class="headerlink" title="没glut glew怎么套到现代函数?"></a>没glut glew怎么套到现代函数?</h1><p><a target="_blank" rel="noopener" href="https://mariuszbartosik.com/opengl-4-x-initialization-in-windows-without-a-framework/">OpenGL 4.x Initialization in Windows without a Framework (mariuszbartosik.com)</a></p>
<p>怎么不用glut和glew, 空手套到现代OpenGL高版本函数.</p>
<p>首先, XP之后, 即Vista开始, 由于API之争, 微软的WindowsSDK只给你OpenGL1.1的gl.h. 但它的opengl32.dll给你一个wglGetProcAddress()方法, 可以用来套那些高版本OpenGL函数.</p>
<p>但这个wglGetProcAddress()需要一个OpenGL rendering context. 这就需要想想办法.</p>
<p>正常情况, 你通过<code>GetDC()</code>获得Device Context, 然后, pick a hardware accelerated pixel format with?<code>ChoosePixelFormat()</code>?and associate it with Device Context using?<code>SetPixelFormat()</code>. Then you can create Rendering Context with?<code>wglCreateContext()</code>?and set it as current with?<code>wglMakeCurrent()</code>. Load new OpenGL functions with?<code>wglGetProcAddress()</code>?and you are ready to use them.</p>
<p>The problem with old?<code>ChoosePixelFormat()</code>?and?<code>wglCreateContext()</code>?is that they are not extensible. For example, the first one uses fixed?<code>PIXELFORMATDESCRIPTOR</code>?structure and there is no field you could set to indicate that you want to request multisampling, sRGB format or floating-point framebuffer support. Using the later one, you cannot ask for specific OpenGL profile or version.</p>
<p>To remedy this, new functions have been created, namely?<code>wglChoosePixelFormatARB()</code>?and?<code>wglCreateContextAttribsARB()</code>. Both of them accepts lists of attributes, so they can support any number of options. There is a small problem, though. To create a rendering context using them, you have to get their function pointers, and for this, you need a rendering context.</p>
<p>Luckily, this can be solved by creating a dummy window and context with old functions, getting new function pointers and creating window and context in the desired format.</p>
<p>接下来就是一波操作. 首先先拉个旧窗口, 用<code>PIXELFORMATDESCRIPTOR</code>随便糊个窗口, 然后用那些ARB函数, 设置PixelFormat, 弄出个能用的Rendering COntext. 最后用这个Context去套OpenGL函数.</p>
<p>现在, 引入OpenGL委员会给的高版本头文件, 你就能把套来的函数地址, 绑到它给的签名上去用了!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/12/opengl/" data-id="clbkhsitc0000lsju3gd649eg" data-title="OpenGL各种东西详解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-math" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/18/math/" class="article-date">
  <time class="dt-published" datetime="2022-10-18T05:06:16.658Z" itemprop="datePublished">2022-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/18/math/">数学是一个永不会完成的创造过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>撰文 | 夏尔·埃雷斯曼（Charles Ehresmann）</p>
<p>翻译 | 叶凌远</p>
<p>译者按</p>
<p>本文是夏尔·埃雷斯曼（Charles Ehresmann，1905-1979）于1966年4月25日在堪萨斯大学劳伦斯分校数学系荣誉晚宴上的演讲，同年发表于Cahiers de topologie et géométrie différentielle catégoriques(《范畴拓扑学与范畴微分几何》) 杂志，题目为“Trends toward unity in mathematics”。埃雷斯曼是一位在德国出生的法国数学家，他是布尔巴基学派的早期成员之一，在微分拓扑和范畴论等领域作出了重要工作。</p>
<p><img src="https://pics2.baidu.com/feed/fcfaaf51f3deb48fccd5fd9a1aeac5202cf57831.jpeg"></p>
<p>夏尔·埃雷斯曼</p>
<p>这篇文章简明地回顾了从古典时代到现代数学的发展历程，阐述了他对于采用范畴论的语言统一不同数学分支的设想。那时距范畴最初的概念在数学文献中正式出现不过21年的时间。到如今，将近60年的时间过去了，范畴论无论是在其自身还是在统一数学方面都有了长足的发展，因此埃雷斯曼文章所规划的蓝图与提出的问题不见得仍在现在的语境下适用。但范畴论发展所取得的成果却没有在更广泛的数学家群体中得到它应有的重视。翻译这篇几乎是60年前的文章，是希望和读者一起回到半个世纪之前，重新思考数学的本质、体会现代数学的思维方式。翻译整体遵照原文，对个别细节进行了修改，注释与粗体均为译者所加。</p>
<p>在常人眼中，数学结论经常被认为是永恒的真理，但数学不是由一成不变的定理所构成的；它也不仅仅产生了大量习题，在其他科学中有广泛的应用而已。数学是一门生动的科学，在持续不断地向前快速发展。我们所处的年代正是数学极速扩张的时代；并且现在，也有一股重要的力量推动着数学迈向统一。</p>
<p>同样的发展导致了新文学的出现——小说不必再有情节；诞生了抽象音乐，有时是由计算机谱写；还有抽象的雕塑和绘画，它们并不旨在呈现真实事物的一般表象。这种同样的抽象过程也发展出了一种新的数学，其动机不在于寻找可能的应用，而是基于我们一种强烈的愿望——希望知晓每一个问题的本质和它所依赖的整体结构。这种一致并不令人惊讶，毕竟数学与艺术非常相似：数学理论不仅需要严格性，还要满足我们对简洁、和谐和美的追求；一个优美的理论和一件艺术品一样，它们都是人类灵感的创造。</p>
<p>对于那些数学家中的柏拉图主义者，他们工作的动机是要寻找给定情景下真实的结构，以及这些结构的抽象表示。对更务实的数学家来说，他努力的目标是用他所掌握的一切手段去解决纯数学或应用数学中出现的预先给定的问题；在此过程中，他会尽可能避免引入新的一般概念。而所有数学家都会认同的是，如果一项数学工作能够激发新的研究产生，那么它在数学中的价值就能得到最好的证明；数学最重要的应用恰恰应是数学本身。</p>
<p>直到最近，大多数哲学家，甚至柏格森[1]，都把数学说成是一门与日常空间中的数与量有关的科学。这个描述或多或少对应着古希腊的数学，但现代数学已不再是如此了。</p>
<p>对希腊人来说，数学代表着算数（Arithmetics）和几何学（Geometry）。前者是关于自然数的科学，后者研究的是日常空间中图形的形状和几何量的比例。尽管他们的几何学是一个公理化的体系，但他们认为这些公理是被“证据”所强加的。事实上，他们在推理中所隐含的假设比明确说明的公理更多。令人惊讶的是，他们从未引入实数的概念，尽管欧多克索斯[2]的比例论与20多个世纪后由戴得金[3]给出的实数定义没有本质上的区别。这种把以前已知的某一类对象——在这里则是一类有理数——作为一个新的对象的抽象过程，对他们的思想来说是完全陌生的。即使是开创了诸如静力学（Statics）和流体力学（Hydrodynamics）等新领域并为积分理论开辟道路的阿基米德，也不愿意抽象地定义实数。在他之后，创造的冲动似乎被耗尽了，而数学在整个中世纪都处于沉睡之中。</p>
<p>数学创造力的复兴还要归功于16世纪意大利数学家引入的新数字，包括负数和虚数，以及同一时期韦达[4]所引入的代数符号。希腊人也有一种基于几何的代数，但他们没有引入任何代数符号，导致他们的作品难以阅读。</p>
<p>笛卡尔和费马也为数学带来了新的推动力，他们创立的解析几何统一了代数和几何。尽管曲线切线的定义问题，以及如何寻找一条曲线的切线等问题已经在非常特殊的情况下得到解决（例如阿基米德的螺旋线），但现在我们可以用一种有效的方式对它们进行研究，这也直接导致牛顿和莱布尼茨发明微积分。莱布尼茨似乎已经猜到了许多未来数学的发展。他不仅明确地将函数作为对象引入数学，从而为泛函分析奠定基础；而且在他尚未实现的通用表意文字（universal characteristics）理论中[5]，他梦想着揭示所有事物的代数结构，并构造一种普世的算法来进行表达和推理。因此，他不满足于笛卡尔的解析几何学，因为它依赖于坐标系的选取。或许是在困惑中，他预见到了几何学必定拥有一种内蕴的代数结构，而线性代数和格拉斯曼代数（编者注：参见《格拉斯曼: 扩展的学问与线之代数丨贤说八道》）可以说部分地实现了他的这个梦想。不幸的是，他所处的时代并不能接受他过于超前的思想，他没有足够的追随者来发展他所设想的道路。不过他在微积分方面的工作被广泛地采用了，特别是他所创立的微分和积分的符号。而微积分也在很长一段时间内成为数学的一个主要的领域。</p>
<p>19世纪由罗巴切夫斯基和亚诺什[6]分别独立发现的非欧几里得几何学是另一进步。截止那时，古典时代为数学所设下的所有界限都被打破了：（欧几里得）几何学不再是由感知经验所强加给我们的，其所依赖的是人类基于公理的创造；我们可以设想不同的公理系统来研究不同的几何学。康德所强调的我们对于空间概念的“先验性（a priori）”由此变得过时了[7]。那么，几何学的本质到底是什么？在当时，人们将一个具有传递性群作用的空间作为几何的统一性概念，例如欧几里得空间的传递群作用事实上就是欧几里得平移变换。因此，几何学成为一个群作用的不变量和共变体的理论。但实际上，这个定义只适用于齐性空间中的几何学，而其他类型的几何已被发现，人们感到有必要对几何和空间的概念进行另外的概括。这最终导致了拓扑空间的定义，它是回答所有关于连续性、极限和近似问题的恰当语境，也使得分析和几何领域中许多共同的结构得以显现。</p>
<p>在同一时期，康托尔[8]的集合理论出现了，并愈发成为所有数学分支统一的基础理论。这是数学中一种新的抽象方式。如康托尔所说，从那时开始“数学的发展就是完全自由的了”，集合论中的概念“只要求不矛盾，并与之前引入的概念通过精确的定义相联系即可”。尽管不久之后，人们发现了一些危及康托尔集合理论的悖论，从而危及整个数学大厦，但康托尔的杰作开启了现代数学思维之路。</p>
<p>自本世纪初以来[9]，数学理论中创造的自由使得人们在集合上考虑了许多新的数学结构。除了各种类型的代数结构（如群、环、域、半群、模、代数、李代数等），还有许多测度和概率模型结构以及对各种各样的拓扑结构的精细化：均匀结构、度量空间、拓扑流形、具有各种微分结构的可微或分析流形，如黎曼流形及其上的联络、代数流形等。考虑同一集合上的不同结构可以构造新的数学对象，如李群、拓扑向量空间、巴拿赫空间、希尔伯特空间、赋范代数，等等。这些结构的引入主要是为了满足纯数学发展的需要，而一旦它们被更多的人所了解，它们在其他领域的应用自然会越来越多，运用数学理论的人也会越来越多。</p>
<p>在引入所有这些不同类型的数学结构之后，人们深切地感受到了统一的必要性；经过一段快速扩张的时期，如果没有一种统一的理论将各个领域联系起来，那么一个无法阻挡的趋势便是，不同的数学家们将和巴别塔的建造者们一样，使用不同的、不相容的数学语言发展各自的领域。</p>
<p>考虑到这些理论的相似性，我们可以通过对结构这一概念，或者更确切地说，集合上某一特定种类的结构的一般性定义得到某种统一。这一思想是由布尔巴基学派[10]发展而来，也是他们编撰的系列教材《数学原本》（léments de mathématique）中内容顺序的编排基础。在数学研究的最开始就被广泛考虑的整数和欧几里得空间这两种结构，一旦被公理化地定义，就非常确定地对应着集合上某一种结构，即所有满足此类结构的对象都是同构的。但现代数学所引入的集合上的不同结构类别（例如群或拓扑结构）并不具有这种唯一性。</p>
<p>集合上一般结构的理论可以用范畴和函子的概念来进行更加普遍的公理化，而范畴论的发展似乎是当今数学最具特色的一种统一的趋势；基于此，我认为它很快就会像其他基础领域一样，如线性代数和拓扑学，在大学早期就被教授。[11]</p>
<p>一个范畴是由一族元素和在它们之上部分定义的复合操作所构成的[12]，同时复合需要满足一定的规则（公理）。例如，每一个群都是一个特殊的范畴，复合操作和群的乘法一致，这使得其中每个元素在这个复合操作下都是可逆的，且只有一个单位元；但最典型的例子还是所有集合间的函数所构成的范畴，其中的一个元素是两个集合之间的一个映射，复合操作则和通常函数之间的复合相一致。抽象范畴的公理化正是基于这个由集合之间的映射构成的范畴所提出的。我们把范畴中一个元素叫作一个态射，而不称其为函数，可以将其想象为从一个物体（态射的源）到另一个物体（态射的靶）的一个箭头。因此，范畴论中态射的一般概念是函数概念的推广，而函数被戴德金认为是数学的基本工具。</p>
<p>函子是范畴之间保持复合操作的映射。它们再次构成了一个范畴，即函子的范畴。对于我们通常所考虑的集合上附加的某种数学结构，它们之间的同态也构成一个范畴。对于所有的这些范畴都可以自然地定义一个函子，映射到之前所述的集合之间的函数所构成的范畴[13]；这通常被称为遗忘函子（forgetful functor），即在这个函子的作用下我们忘记了集合上其它的结构，仅仅保留了最基本集合的信息。例如，所有拓扑空间之间的连续映射构成的范畴，亦或是所有群同态所构成的范畴，都有如上所述的遗忘函子。</p>
<p>现在，我们可以更抽象地考虑从范畴H到范畴C的任意一个函子p。根据上面的讨论，在这个语境下，我们则可以将H的任意一个物体S看作是相对于函子p的一个结构，或更确切地说是C范畴中的物体p(S)上的一个p-结构。因此，H可以看作是C上的p-结构所构成的范畴。令人惊讶的是，许多有关集合上某种特定结构的理论和构造可以被如上所述有关 p-结构的一般理论所统一起来。我们可以在这个框架下定义子结构、商结构、自由结构、笛卡尔积、一族物体的和，或更为广泛的任意一个函子的极限和余极限，等等。目前我相信，现在的数学研究将会更少地关心单个p-结构的性质，甚至也不会那么关心某一个函子p的性质；相反，现在数学的目标应该是研究某一族函子的性质，使得曾经对于某一特定函子p和其对应的p-结构成立的定理，现在对于这一族中任意的函子都成立。一旦理解了这个定理有效的真正原因，我们一般会发现，只有很少的一些条件（假设）是证明这个定理所真正必要的。因此，原来定理的证明如今可以推广到一类非常广泛的函子上，而不仅仅只对原本的p函子适用。特别地，这个定理可能会包含许多已知的函子，从而应用于我们从未想过的领域。例如，有关拓扑空间的紧致化，均匀空间的完备化，自由群、自由模或更一般的由一个集合生成的自由代数的构造，都可以看作是某一类抽象的函子自由结构存在性定理的推论。</p>
<p>当然，上述对数学进行统一的方案过于粗略。事实上，只有数学家们的创造力才能持续地发现新的有趣的函子类。如我们所见，在数学中，创造过程的一个特点是把以前定义的一类对象作为一个新的数学对象来加以认识。当我们开始研究不同函子的分类及其性质来梳理统一现有的数学理论时，我们是否在这个更高的层次面临着相同的问题？一旦这个新理论走向成熟且再次变得复杂、纠缠不清，我们是否有必要发展更高程度的统一理论？我们不试图回答这个问题。然而，我们愈发深刻地认识到，数学是一个永不会完成的创造过程，它的存在性并不需要通过它的重要性或是不断扩大的应用范围来证明；它的意义远远不仅是充当“物理学的推土机”。数学是理解整个宇宙的关键，统一了人类从科学到哲学到形而上学的所有的思维。因此，柏拉图和莱布尼茨的伟大理想，即让数学成为一切知识本质的理想，可能终将实现。</p>
<p>注释</p>
<p>[1] 亨利·柏格森 (Henri Bergson, 1859-1941)，法国哲学家，文学家，于1927年凭借丰富、富有活力的思想和语言获得诺贝尔文学奖（译者注；全文所有的脚注均为译者所加，后不再一一指明）。</p>
<p>[2] 欧多克索斯（Eudoxus，408 B.C.–355 B.C. ），古希腊数学家、天文学家，欧几里得《几何原本》中的许多内容很有可能是来源于欧多克索斯，一些人认为他是古希腊最杰出的数学家。</p>
<p>[3] 里查德·戴得金（Richard Dedekind，1831-1916），德国数学家，在数论、抽象代数（特别是环论）以及算数的公理化等领域作出非常重要的贡献。</p>
<p>[4] 弗朗索瓦·韦达（Franois Viète，1540-1603），法国数学家，初高中生们熟悉的韦达定理就来源于他。</p>
<p>[5] 通用表意文字 （拉丁语为characteristica universalis），是莱布尼茨所设想的一种通用的形式化语言，该语言能够表达数学、科学以及形而上学等方面的概念，并支持一种通用的逻辑演算。</p>
<p>[6] 尼古拉·罗巴切夫斯基（Nikolai Lobachevsky，1792-1856 ），俄国数学家；鲍耶·亚诺什（János Bolyai, 1802-1860），匈牙利数学家，他们和高斯生活在同一时代。两人均独立的为非欧几何，特别是双曲几何，作出了重要贡献。</p>
<p>[7] 康德认为人类对时间和空间的认识不是通过概念化（conceptualisation）的方式完成的，它们是我们感观直觉的纯粹形式（pure form of sensible intuition）。非常粗略地来说，前者涉及知性（understanding）的运作，而后者形成的知识则是先验的。</p>
<p>[8] 格奥尔格·康托尔（Georg Cantor，1845-1918），是出生于俄国的德国数学家，创立了现代集合论，是实数的严格定义及整个微积分体系的理论基础，为数学基础（foundation of mathematics）作出了杰出的贡献。</p>
<p>[9] 这里指本文成文的时间，即20世纪。</p>
<p>[10] 尼古拉·布尔巴基（Nicolas Bourbaki）是20世纪一群法国数学家的共同笔名，他们自1935年开始撰写一系列关于现代高等数学的书籍，以把所有数学建立在集合论坚实的基础之上为目的。在这个过程中，他们致力于将数学概念尽可能地普遍化和严谨化， 对20世纪之后的数学发展产生了深刻的影响。</p>
<p>[11] 范畴论最早起源于1945年Eilenberg和MacLane 的题为General Theory of Natural Equivalences的论文，在随后的几十年内作为一门数学语言和工具迅速地参与到各个数学分支的发展之中。遗憾的是，本文作者埃雷斯曼的这一猜测直到多年后的今天也没能在大多数的大学内成为现实。</p>
<p>[12] 在现代的范畴论语言中，一般把范畴定义为两种类别的元素，即物体和它们之间的态射，所构成的数学对象；但也可以仅仅将一个范畴理解为一族态射加上上面部分定义的复合操作，因为范畴中的物体和单位态射是一一对应的。换句话说，态射的信息包含了物体的信息。本文对范畴所采取的是后一种理解。</p>
<p>[13] 即把一个同态看作是其对应的集合之间的函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/18/math/" data-id="cl9dqw5m30001yoju8i6cdg4h" data-title="数学是一个永不会完成的创造过程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-wisdom" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/17/wisdom/" class="article-date">
  <time class="dt-published" datetime="2022-10-17T15:23:46.108Z" itemprop="datePublished">2022-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/17/wisdom/">生活中的智慧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>叙事  2020-06-09</p>
<p>曾经我问过爸爸，什么是智慧？哪里有智慧？爸爸告诉我：“生活中处处都有智慧。”那时, 我还是不怎么明白。</p>
<p>有一次，奶奶在厨房准备午饭，我便待在那看。只见奶奶淘了米后，把淘米水放在一旁，便去择菜了。我不禁问道：“奶奶，淘米的水都变白了，怎么不倒掉呢？”“淘米水用处可多啦！”奶奶说，“淘米水不仅可以洗碗洗菜，还可以洗脸呢，它有美容养颜的功效！”</p>
<p>“洗脸？”我有些半信半疑。这时，奶奶用淘米水洗起了菜，洗完菜后，又把水拿来浇花。“你看你这样一水多用，多节约呀！”奶奶又对我说。除了一水多用，奶奶平常还会把一些塑料袋存起来，当垃圾袋使用。虽然奶奶没有读过很多书，但在生活上，有自己的小智慧。不仅在节约上有智慧，身边一些不起眼，但使我们更方便的东西，也是因为智慧。以前，我一直觉得爷爷那电瓶车的银色垫子没什么用，只是为了美观罢了。但实际上，夏天也会发挥很大的作用，它能使坐垫不会被太阳晒得滚烫。这是为什么呢? 老师说：“这是因为垫子是银色的，表面很光滑，反射光的本领特别强，吸热本领就弱了，所以它在太阳下升温就比较慢，同样，白色吸热本领也弱，因此，夏天人们都喜欢穿白色衣服，这些都是智慧与科学的力量。”</p>
<p>原来生活中真的处处都有智慧，智慧的力量是如此的强大！它既可以节约资源，保护环境，又可以使我们的生活更方便。只要我们用心去观察，去实践，去发掘，就能发现智慧无处不在！<br>点评：能够选择生活中具有典型意义的题材，事件的代表性较强。Array。情节波折性较强，于平常之中生意外，能引起读者的注意。全文叙事集中，不枝不蔓，语言朴实流畅，感情真挚感人。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/17/wisdom/" data-id="cl9dqw5tf0002yoju6pah4rdw" data-title="生活中的智慧" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/17/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-10-17T15:16:29.626Z" itemprop="datePublished">2022-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/17/hello-world/">做一个幸福的人</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>周记  2021-10-21</p>
<p>如果人生是鱼，那么幸福就是水；如果人生是飞鸟，那么幸福就是天空；如果人生是蜜蜂，那么幸福就是花朵。人生离不开幸福，没有幸福的人生是毫无意义的人生</p>
<p>有这样一些幸福的人，他们有自己的兴趣和爱好，他们过着自由自在无拘无束的生活。徐霞客一生浏览无数大好河川，感受到了山人合一的自由，这就是他的幸福；陶渊明不愿在昏暗无边的官场上活着，他要到田园里尽情享受那“采菊东篱下，悠然见南山”的悠闲，这就是他的幸福。其实，幸福来的很简单：只要你做自己喜欢的事，还要在道德和法律允许的范围内进行体验幸福生活的情趣，就会成为一个幸福的人。</p>
<p>有这样一些幸福的人，他们用自己的努力来造福人类，使人们的生活更加美好。诺贝尔看见劳动的工人太辛苦，下决心要帮助他们，于是埋头苦干，刻苦钻研，在实验室里花四年时间，试验一百多次，最终发明了对人类作用巨大的火药。当他发明出火药时，幸福感布满了他的全身，因为他能用他的努力来造福人类。其实，幸福来的很简单：只要你用自己的努力一心一意的来帮助别人，就会成为一个幸福的人。</p>
<p>有这样一些幸福的人，他们背负着各种各样的责任，使自己努力完成自己的使命。岳飞作为国家危亡时的得力将领，他有责任在边疆奋勇杀敌，收复失地，甚至为国捐躯。这种责任感使他一往无前，完美地演绎着一场场胜利，看着这一块块失而复明得的土地时，幸福也一块块地充斥着他的心中。其实，幸福经常来的很简单：只要你背负着使命与责任，并且把它化为前进的动力，你就会成会一个幸福的人。</p>
<p>人生离不开幸福，要牢记上述的幸福要诀，做一个幸福的人。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/17/hello-world/" data-id="cl9dqw5k50000yoju80ndgrd6" data-title="做一个幸福的人" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/12/coroutine-revisit/">继续思考coroutine</a>
          </li>
        
          <li>
            <a href="/2023/01/11/hexo/">Hexo怎么用</a>
          </li>
        
          <li>
            <a href="/2023/01/11/haskell/">Haskell配置笔记</a>
          </li>
        
          <li>
            <a href="/2022/12/13/coroutine/">coroutine解剖麻雀</a>
          </li>
        
          <li>
            <a href="/2022/12/12/opengl/">OpenGL各种东西详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>