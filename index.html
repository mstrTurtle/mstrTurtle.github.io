<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>mstrTurtle的生活智慧</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="mstrTurtle的生活智慧">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="mstrTurtle的生活智慧">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Master Turtle">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="mstrTurtle的生活智慧" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mstrTurtle的生活智慧</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式/memento" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/memento/" class="article-date">
  <time class="dt-published" datetime="2023-09-04T16:00:00.000Z" itemprop="datePublished">2023-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OO%E8%AE%BE%E8%AE%A1/">OO设计</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/memento/">Memento模式实现角色状态恢复</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>备忘录模式：不破坏封装的情况下捕获某对象的内部状态，在其外存储此状态。这样就能在某时刻将其恢复到原先状态。</p>
<p>Originator（发起人）：负责创建一个Memento。并可以使用其恢复状态。可以自行掌控需要往Memento里存啥。
Memento（备忘录）：存储Originator内部状态，防止除Originator以外的人看到状态。
Caretaker（管理者）：只管存储好备忘录，不能对其操作or检查。</p>
<hr>
<p>简单总结一下，Originator只管创造Memento、用其回复状态。
Memento不仅是一个ADT，还需要管理好其权限，只能让Originator看到内部状态。
Caretaker负责保管好备忘录。</p>
<hr>
<p>下面的范例是知乎摘出来的，经过评论区指正，有一些缺点：
Memento的权限管理得不好，getState是public的。为了改正这一情况，需要
把restoreState放在Memento里，把getState拿掉。（<code>Memento::restoreState(Originator&amp; originator)</code>）
还有另一种解法：Memento作为GameRole的私有内部类。（我觉得这是说错了，外部没法存储Memento）</p>
<hr>
<p>一个简单的范例：</p>
<p>有一个游戏角色，拥有血量、攻击力、防御力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class GameRole &#123;</span><br><span class="line">	private int vit; // 生命力</span><br><span class="line">	private int atk; // 攻击力</span><br><span class="line">	private int def; // 防御力</span><br><span class="line">	// 初始化状态</span><br><span class="line">	public void initState()&#123;</span><br><span class="line">		this.vit = 100;</span><br><span class="line">		this.atk = 100;</span><br><span class="line">		this.def = 100;</span><br><span class="line">	&#125;</span><br><span class="line">	// 战斗</span><br><span class="line">	public void fight()&#123;</span><br><span class="line">		this.vit = 0;</span><br><span class="line">		this.atk = 0;</span><br><span class="line">		this.def = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public RoleStateMemento saveState()&#123;</span><br><span class="line">		return &#123;vit, atk, def&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public recoverState(RoleStateMemento m)&#123;</span><br><span class="line">		this.vit = m.getVit();</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void stateDisplay()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;角色生命力：&quot; ++ vit;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class RoleStateMemento&#123;</span><br><span class="line">	private int vit; // 生命力</span><br><span class="line">	private int atk; // 攻击力</span><br><span class="line">	private int def; // 防御力</span><br><span class="line">	// 一堆setter, getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class RoleStateCaretaker&#123;</span><br><span class="line">	private RoleStateMemento m;</span><br><span class="line">	// m 的 getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/memento/" data-id="clm5pkjbi0000qsju8cp079gk" data-title="Memento模式实现角色状态恢复" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-proactor-messageblock" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/05/proactor-messageblock/" class="article-date">
  <time class="dt-published" datetime="2023-09-04T16:00:00.000Z" itemprop="datePublished">2023-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/05/proactor-messageblock/">ACE用Proactor与Message Block、Queue处理分包、粘包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="FROM"><a href="#FROM" class="headerlink" title="FROM:"></a>FROM:</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alger_lzl/article/details/11970077">ACE数据接收中粘包及半包的处理_alger_lzl的博客-CSDN博客</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在使用TCP协议的网络应用中，不可避免需要处理的一个问题就是半包和粘包的情况。</p>
<p>一种做法是在接收端设一个<strong>比较大的缓冲区</strong>，先将收到的数据包都放到缓冲区中，
然后从该缓冲区中选取完整的 数据包出来。该缓冲区的实现可以使用环形缓冲区进行优化，避免频繁的数据移动。
使用该方法的一个描述见  <a target="_blank" rel="noopener" href="http://www.vckbase.com/document/viewdoc/?id=1203">http://www.vckbase.com/document/viewdoc/?id=1203</a></p>
<p>另外一种做法就是在接收的时候就只接收完整包。
这要求数据包有<strong>固定的包头结构体，其中还要包含数据包的长度信息</strong>。
在服务端接收的时候，先接收该包头数据，然后再接收指定长度的数据体。</p>
<p>在ACE中，用于保存消息的<strong>ACE_Message_Block有一个重要的特性：复合</strong>。
即将多条消息连接在一起，形成一个单链表。
这样便可以将<strong>先收到的包头和后收到的包体连成一个复合体</strong>，而不用建一个大的数据包，将两个Message_Block拷贝进去。</p>
<p>下面的示例采用ACE的<strong>Proactor框架</strong>完成，实现了服务器端<strong>半包及粘包的处理，以及ACE_Message_Block的复合，网络IO与逻辑处理的分离</strong>。</p>
<p>在Proactor框架中，接收新连接后，会初始化一个读请求，此时只要求<strong>读包头长度</strong>的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init_read_stream()</span><br><span class="line">&#123;</span><br><span class="line">    ACE_NEW_NORETURN (recv_data_, ACE_Message_Block (sizeof(PacketHeader), MB_NORMAL_PACKET));</span><br><span class="line">    ACE_HANDLE handle = this-&gt;handle ();</span><br><span class="line">    this-&gt;recv_data_-&gt;copy ((const char *)&amp;handle, sizeof(ACE_HANDLE));</span><br><span class="line">    this-&gt;reader_.read (*recv_data_, recv_data_-&gt;space ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里由于使用了<strong>网络IO与逻辑处理分线程处理</strong>的方式，
递交给<strong>逻辑线程的数据包前面还加上了标识网络连接的handle</strong>，用以告诉逻辑线程该数据包是哪个客户端连接发上来的。</p>
<h2 id="接收包头"><a href="#接收包头" class="headerlink" title="接收包头"></a>接收包头</h2><p>递交给逻辑线程的数据包头结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct PacketHeader</span><br><span class="line">&#123;</span><br><span class="line">	ACE_HANDLE handler;</span><br><span class="line">	int data_length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中data_length就是从接收到的数据包中获取到的。</p>
<p>对于粘包的情况比较容易处理，先收了包头后再接收指定长度的数据包，多余的数据由下次再读取。
半包情况稍微复杂一点，每个数据包是分两次接收的，两次接收的时候都有可能接收不完全。</p>
<p><strong>当接收包头不完全时所做的处理是继续提交读请求</strong>，读的数据长度为剩余的包头长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (this-&gt;recv_data_-&gt;length() &lt; sizeof(PacketHeader))</span><br><span class="line">&#123;</span><br><span class="line">    // 数据包长度信息还未接收完</span><br><span class="line">    this-&gt;reader_.read (*recv_data_, recv_data_-&gt;space ());</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收数据体"><a href="#接收数据体" class="headerlink" title="接收数据体"></a>接收数据体</h2><p>当包头接收完后，<strong>新建一个Message_Block，长度为需要接收的数据体长度</strong>，并将该Message_Block<strong>链接到包头后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PacketHeader * hdr = reinterpret_cast&lt;PacketHeader *&gt; (this-&gt;recv_data_-&gt;rd_ptr());</span><br><span class="line">ACE_Message_Block * data_mb = this-&gt;recv_data_-&gt;cont();</span><br><span class="line">if (!data_mb)</span><br><span class="line">&#123;</span><br><span class="line">    // 刚刚接收完长度信息</span><br><span class="line">    ACE_NEW (data_mb, ACE_Message_Block(hdr-&gt;data_length));</span><br><span class="line">    this-&gt;recv_data_-&gt;cont (data_mb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果该数据包的包体接收完全，则将该完整的数据包发送到逻辑线程的消息队列，然后初始化一个新的接收请求</span><br><span class="line">if (data_mb-&gt;length () == hdr-&gt;data_length)</span><br><span class="line">&#123;</span><br><span class="line">    // 数据已接收完</span><br><span class="line">    // 再继续接收下一个数据包</span><br><span class="line">    logic_thread-&gt;putq (recv_data_);</span><br><span class="line">    this-&gt;init_read_stream();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则表示数据体还未接收完全，处理方法也是继续提交剩余数据的读请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;reader_.read (*data_mb, data_mb-&gt;space ());</span><br></pre></td></tr></table></figure>

<p>直接该数据包读取完全。</p>
<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>数据包接收处理函数的<strong>完整实现</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">virtual void handle_read_stream (const ACE_Asynch_Read_Stream::Result &amp;result)</span><br><span class="line">&#123;</span><br><span class="line">	ACE_Message_Block &amp;mb = result.message_block ();</span><br><span class="line">	if (!result.success () || result.bytes_transferred () == 0)</span><br><span class="line">	&#123;</span><br><span class="line">	   mb.release ();</span><br><span class="line">	   delete this;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">	   if (this-&gt;recv_data_-&gt;length() &lt; sizeof(PacketHeader))</span><br><span class="line">	   &#123;</span><br><span class="line">			// 数据包长度信息还未接收完</span><br><span class="line">			this-&gt;reader_.read (*recv_data_, recv_data_-&gt;space ());</span><br><span class="line">			return;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   PacketHeader * hdr = reinterpret_cast&lt;PacketHeader *&gt; (this-&gt;recv_data_-&gt;rd_ptr());</span><br><span class="line"></span><br><span class="line">	   ACE_Message_Block * data_mb = this-&gt;recv_data_-&gt;cont();</span><br><span class="line">	   if (!data_mb)</span><br><span class="line">	   &#123;</span><br><span class="line">		    // 刚刚接收完长度信息</span><br><span class="line">		    ACE_NEW (data_mb, ACE_Message_Block(hdr-&gt;data_length));</span><br><span class="line">		    this-&gt;recv_data_-&gt;cont (data_mb);</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   if (data_mb-&gt;length () == hdr-&gt;data_length)</span><br><span class="line">	   &#123;</span><br><span class="line">		    // 数据已接收完</span><br><span class="line">		    // 再继续接收下一个数据包</span><br><span class="line">		    logic_thread-&gt;putq (recv_data_);</span><br><span class="line">		    this-&gt;init_read_stream();</span><br><span class="line">		    return;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   // 否则继续接收该数据包</span><br><span class="line">	   this-&gt;reader_.read (*data_mb, data_mb-&gt;space ());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/05/proactor-messageblock/" data-id="clm5zivgd0000g0jucmgedfk8" data-title="ACE用Proactor与Message Block、Queue处理分包、粘包" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-header-only-lib" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/04/header-only-lib/" class="article-date">
  <time class="dt-published" datetime="2023-09-04T14:54:43.187Z" itemprop="datePublished">2023-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/">编译链接</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/04/header-only-lib/">C++将项目改造成纯头文件库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-Digest"><a href="#1-Digest" class="headerlink" title="1 Digest"></a>1 Digest</h1><h2 id="1-1-来源"><a href="#1-1-来源" class="headerlink" title="1.1 来源"></a>1.1 来源</h2><p>可不可以把任意一个c++库改写成纯头文件库？ - WhoTFAmI的回答 - 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/525003410/answer/2420228940">https://www.zhihu.com/question/525003410/answer/2420228940</a></p>
<h2 id="1-2-include-guard"><a href="#1-2-include-guard" class="headerlink" title="1.2 include guard"></a>1.2 include guard</h2><p>循环依赖无需考虑，用include guard就好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XXX</span></span><br><span class="line"><span class="comment">// blah blah</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YYY</span></span><br><span class="line"><span class="comment">// blah blah</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>不是大问题。关键是链接、名字冲突问题。</p>
<h2 id="1-3-先不考虑多编译单元"><a href="#1-3-先不考虑多编译单元" class="headerlink" title="1.3 先不考虑多编译单元"></a>1.3 先不考虑多编译单元</h2><p>直接把各个命名空间里面冲突的函数、变量、常量、类改一个全局唯一的名字。</p>
<h2 id="1-4-多编译单元命名冲突处理"><a href="#1-4-多编译单元命名冲突处理" class="headerlink" title="1.4 多编译单元命名冲突处理"></a>1.4 多编译单元命名冲突处理</h2><p>static&#x2F;匿名空间内的匿名 union需要改成不匿名的 union 类型 + inline 变量。</p>
<h2 id="1-5-多编译单元函数的处理"><a href="#1-5-多编译单元函数的处理" class="headerlink" title="1.5 多编译单元函数的处理"></a>1.5 多编译单元函数的处理</h2><p>函数声明默认是extern的，函数定义默认是internal linkage的。</p>
<p>函数好办，全加上inline就行。</p>
<h2 id="1-6-多编译单元全局变量的处理"><a href="#1-6-多编译单元全局变量的处理" class="headerlink" title="1.6 多编译单元全局变量的处理"></a>1.6 多编译单元全局变量的处理</h2><p>全局变量默认是internal linkage。除非你标出了extern。</p>
<p>如果internal linkage的东西在预处理阶段被照抄进cpp，多个cpp又被ld链接器进行链接，
那么两个编译单元里出现两个相同的定义，将会违反ODR（One Definition Rule）原则，
造成未定义行为！</p>
<p>在传统头文件实现分离的方法中，我们只需要在头文件里把变量标成extern，在任一实现文件定义其即可。
在纯头文件库里，需要直接改成外部链接并加上inline说明符。</p>
<p>注意这个全局变量的inline在C++17标准才启用。在C++17之前，header only里的全局变量都是要用inline函数返回静态变量的指针or引用。
这种做法在C++11之后是附带了线程安全初始化的，有开销。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可不可以把任意一个c++库改写成纯头文件库？ - 知乎用户u44DoS的回答 - 知乎 https://www.zhihu.com/question/525003410/answer/2414822441">1</span></a></sup></p>
<p>还需注意，在此之前，全局非const变量，<strong>非模板类的静态变量</strong>，都是纯头文件化的阻碍。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可不可以把任意一个c++库改写成纯头文件库？ - IceBear的回答 - 知乎 https://www.zhihu.com/question/525003410/answer/2419575784
">2</span></a></sup></p>
<h1 id="2-原文摘要"><a href="#2-原文摘要" class="headerlink" title="2 原文摘要"></a>2 原文摘要</h1><h2 id="2-1-单个cpp文件情形"><a href="#2-1-单个cpp文件情形" class="headerlink" title="2.1 单个cpp文件情形"></a>2.1 单个cpp文件情形</h2><p>如果要求头文件只会被 <strong>一个</strong> 翻译单元（.cpp文件）包含，需要做：</p>
<ul>
<li>把全局&#x2F;命名空间内的内部链接（internal linkage）的函数、变量、常量、类，改一个全局唯一的名字。</li>
<li>只在原来的翻译单元中的定义的宏，改一个全局唯一的名字</li>
</ul>
<h2 id="2-2-多个cpp文件情形"><a href="#2-2-多个cpp文件情形" class="headerlink" title="2.2 多个cpp文件情形"></a>2.2 多个cpp文件情形</h2><p>如果要求头文件可以被 <strong>多个</strong> 翻译单元（.cpp文件）包含，<strong>还</strong> 需要做：</p>
<ul>
<li>把全局&#x2F;命名空间内的外部链接（external linkage）的函数、变量声明加上 inline 说明符</li>
<li>把全局&#x2F;命名空间内的内部链接的函数、变量、常量、类型、匿名空间，取一个全局唯一的名字，改成外部链接且加 inline 说明符。如果做得细致点，可以只改那些被 odr-use 的，但基本上全部都会被 odr-use 的，而且谁知道它未来会不会被新代码 odr-use。</li>
<li>static&#x2F;匿名空间内的匿名 union（如果有的话），git blame 把作者拉出去批斗一番，然后改成不匿名的 union 类型 + inline 变量。</li>
</ul>
<p>需要动刀的内部链接的东东基本上是这些：</p>
<ul>
<li>全局&#x2F;命名空间内的 static 变量、static 函数</li>
<li>全局&#x2F;命名空间内的<strong>未</strong>声明为 inline 的常量(const)</li>
<li>匿名空间及其里面的名字（变量、常量、函数、类型）</li>
</ul>
<p>需要注意的是，C++的全局&#x2F;命名空间内的没有 inline 说明符的常量（const）是内部链接的。所以如果你的头文件中有定义常量，记得加上 inline，否则极其容易被 odr-use，导致未定义行为（理论上）。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可不可以把任意一个c++库改写成纯头文件库？ - 知乎用户u44DoS的回答 - 知乎 https://www.zhihu.com/question/525003410/answer/2414822441<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可不可以把任意一个c++库改写成纯头文件库？ - IceBear的回答 - 知乎 https://www.zhihu.com/question/525003410/answer/2419575784<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/04/header-only-lib/" data-id="clm506v5c0000n0jua9aoavds" data-title="C++将项目改造成纯头文件库" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式/effective-cpp-24" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/effective-cpp-24/" class="article-date">
  <time class="dt-published" datetime="2023-09-03T16:00:00.000Z" itemprop="datePublished">2023-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/OO%E8%AE%BE%E8%AE%A1/">OO设计</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/effective-cpp-24/">Effective C++ 条款23：多用non member函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="梗概"><a href="#梗概" class="headerlink" title="梗概"></a>梗概</h2><p>类的成员变量应当被藏起来，这就是封装。
每当一个public成员函数出现，都是把此成员变量曝光了，这样就降低了类本身的封装性。</p>
<p>我们不该将一些public函数的组合函数，也就是一些工具类，硬套在相应的类上。
事实上，这反而降低了封装度。我们应当把它弄成non member的，来减少类本身的披露。</p>
<p>更进一步，通过C++的namespace机制，我们可以把相互之间差异极大的Util函数装进Util命名空间。
这样做不仅能把不同关注点的工具类分到不同头文件中，还能够方便用户往里边加东西。</p>
<h2 id="浏览器Browser的设计场景"><a href="#浏览器Browser的设计场景" class="headerlink" title="浏览器Browser的设计场景"></a>浏览器Browser的设计场景</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Browser</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCookie</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>&#123; <span class="comment">// 选择1</span></span><br><span class="line">        <span class="built_in">clearCache</span>();</span><br><span class="line">        <span class="built_in">clearHistory</span>();</span><br><span class="line">        <span class="built_in">clearCookie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">(Browser&amp; b)</span></span>&#123; <span class="comment">// 选择2</span></span><br><span class="line">    b.<span class="built_in">clearCache</span>()</span><br><span class="line">    b.<span class="built_in">clearHistory</span>();</span><br><span class="line">    b.<span class="built_in">clearCookie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何抉择？Effective C++ 条款23告诉我们，答案是选择2——non member函数！</p>
<h2 id="non-member相较之下提升了封装性"><a href="#non-member相较之下提升了封装性" class="headerlink" title="non member相较之下提升了封装性"></a>non member相较之下提升了封装性</h2><p>成员变量（类的数据）应为private。否则就有无穷多的函数可以访问它们。无穷降低了封装性。</p>
<p>采用non-member的原因：如果是member，那就多了一个能访问到private变量的函数。降低了Browser类的封装性。</p>
<h2 id="采用non-member的特殊情况"><a href="#采用non-member的特殊情况" class="headerlink" title="采用non member的特殊情况"></a>采用non member的特殊情况</h2><p>但对于已经是friend的来讲，已经让它访问到成员变量了。所以member不member无所谓。此时你应该考虑no friend no member是否可行。</p>
<p>隐式类型转换可以考虑是否member.</p>
<h2 id="考虑放另一个Util类里"><a href="#考虑放另一个Util类里" class="headerlink" title="考虑放另一个Util类里"></a>考虑放另一个Util类里</h2><p>未必不能是另一个类（Util）的member。反正它是Util的member，并不影响对Browser的封装性的破坏。</p>
<h2 id="namespace的好处"><a href="#namespace的好处" class="headerlink" title="namespace的好处"></a>namespace的好处</h2><p>在C++中，弄一个namespace会带来更好的好处。</p>
<p>一般Util内的不同函数都大相径庭，八竿子打不着。通过namespace，可以把这些函数放进不同的头文件（区别于class，只能写一起），实现一些分离。</p>
<h2 id="namespace额外好处"><a href="#namespace额外好处" class="headerlink" title="namespace额外好处"></a>namespace额外好处</h2><p>namespace还可以增强扩展性，用户随便在哪儿写一个扩展就行了。</p>
<p>但class的话，客户得去改库代码，或者得手动派生。派生是有问题的：
Derived没法访问Base里的private，只能是“次级身份”了。</p>
<p>毕竟不是所有类都被设计成Base用，专门给你派生的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/effective-cpp-24/" data-id="clm4wkvih0000fgjuey9eah6l" data-title="Effective C++ 条款23：多用non member函数" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-dynamic-cast" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/dynamic-cast/" class="article-date">
  <time class="dt-published" datetime="2023-03-08T16:00:00.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/09/dynamic-cast/">dynamic_cast与虚继承</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚继承-虚函数-虚表-dynamic-cast"><a href="#虚继承-虚函数-虚表-dynamic-cast" class="headerlink" title="虚继承, 虚函数, 虚表, dynamic_cast."></a>虚继承, 虚函数, 虚表, dynamic_cast.</h1><p>参考资料:</p>
<ul>
<li><em>CppCon dynamic_cast from scratch Arthur O’Dwyer 2017-09-26</em> <ul>
<li>里面给出了CatDog例子, 给出了详细的虚表样例, 以及给出作者自己的实现, 并且对照了Itanium ABI和微软ABI.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118541570">(68条消息) C++ RTTI详解_彼 方的博客-CSDN博客</a><ul>
<li>这篇CSDN文章也shed some light on RTTI(typeid operator, class type_info), 又援引了三篇有用的文献.</li>
<li>其中引用的文献:<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118196343">一文读懂C++虚函数的内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118369498">一文读懂C++虚继承的内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118424172">深入理解C++中五种强制类型转换的使用场景</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>如是我闻:</strong></p>
<p>虚继承, 比如菱形继承的”Animal Cat Dog CatDog”, Animal就会有两份.</p>
<p>CppCon那个CatDog示例里, 有个类布局图(data layout). 可以看到不virtual继承的话, 一个CatDog实例会躺着两个Animal.</p>
<p>CatDog中, 你也不能把一个CatDog指针直接转成Cat或者Dog类型指针, 因为指针指的是你的内存布局顶部, 但Cat Dog躺在哪儿还说不准呢, 反正肯定不是内存布局顶部.</p>
<p>虚函数就对应了虚函数表(通常称为虚表). g++有虚函数表, 没有虚继承表. VS据说有虚继承表. 某<em>中间导出类型</em>的<em>子虚表</em>的-1下标处, 即vptr-1那个位置, 放着个指向type_info的指针. 在vptr-2处, 甚至有md-offset, 即”最大导出类型most-derived偏移”, 是从”子虚表”到达”最大导出虚表”的位移量! Cat的再往这前面(vptr-3之类), 竟然还有从md指向Animal的offset(当然这是Itanium ABI的格式)</p>
<p>众所皆知类实例只是放数据的地方, 函数本体都在前面代码区放着. 有些函数调用能在编译期锁定位置, 而有些不能, 需要动态锁定. 此时vptr和vtbl就是媒介. 编译期总能确定函数名, 而运行期类实例自带一个vptr. 运行期调用函数时, 会去找vptr, 指向它所属类的vtbl, 然后加上一个编译期已知的偏移量. 这样就找到了真实类的对应函数.</p>
<p>多继承会造成有多个vptr, 比如CatDog那个, 若Animal不弄成虚基类, 那么Cat和Dog的Animal会各自有个vptr. 如果菱形继承, 甚至Animal被弄到data layout下面去了, 现在有3个vptr. </p>
<p>光是多继承倒还好, 毕竟Cat, Dog, CatDog的data layout和函数指针都是concret的. 但当引入虚基类, 一个<code>Cat*</code>底下的数据布局将不再确定! 它底下的Animal可能在布局的前面, 也可能在它后面不远处.</p>
<p>你的”最大导出类型”(most-derived class, MDC)决定了一个虚表. 在最大导出类型和最基本类型中间卡着的那些类型, 它们的vptr都是去找这虚表里的东西的. 也就是说, 中间导出类型对应的虚表是”子虚表”. 当给出一个”最大导出类型”和”中间导出类型”, 就能决定一些具体的虚表项.</p>
<p>至于dynamic_cast, 它能在菱形继承中, 把一个本体是CatDog的指Cat的指针转成指Dog指针, 相应地赋予位置上的改变. 它利用的是type_info提供的RAII功能, 先看看它真的类型(type_info里有标), 得出编译期弄出来的饱含语义信息的继承图(必须由编译器生成这些额外信息, 否则运行时是弄不出来这些的). 图的连边饱含了转换信息(如non-public继承不能转, 其他那些继承的转换在连边处给出了offset). 然后用DFS的法子找到路, 并一步步转过去.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/09/dynamic-cast/" data-id="clf180c950000ewjueswf306b" data-title="dynamic_cast与虚继承" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ime-research" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/ime-research/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:47:44.513Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/ime-research/">Win10控制台应用IME研究</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>源自我的知乎回答: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/381963138/answer/2876498622">win10如何切换输入法？</a></p>
<p>如何用全局快捷键, 切换到指定输入法? 一种思路是用窗口事件，另一种是ActivateKeyboardLayout。后者有待研究, 但至少前者是管用的，并将在下文叙述。</p>
<p>在下文所述切输入法方法的基础上，加以完善，就能实现完整可用的程序。具体的完善方法为：写一个后台服务, 捕获全局快捷键, 获得当前焦点窗口的hWnd, 然后按下文所述方法，给它发切输入法的消息。</p>
<h1 id="概念说明："><a href="#概念说明：" class="headerlink" title="概念说明："></a>概念说明：</h1><p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://support.microsoft.com/en-us/windows/manage-the-input-and-display-language-settings-in-windows-12a10cb4-8626-9b77-0ccb-5013e0c7c7a2#:~:text=To%20switch%20the%20keyboard%20layout%20you%27re%20using%20in%20Windows,through%20all%20your%20installed%20keyboards.">Manage the input and display language settings in Windows - Microsoft Support</a></p>
<p>得出，KeyboardLayout指Tray里的方框。</p>
<p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/dxtecharts/using-an-input-method-editor-in-a-game">Using an Input Method Editor in a Game - Win32 apps | Microsoft Learn</a></p>
<p>得出，此方框也叫Input Locale Indicator。</p>
<p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/intl/about-input-method-manager">About Input Method Manager - Win32 apps | Microsoft Learn</a></p>
<p>IMM只在安装了东亚Locale时，才会启用；IMM会创造IME。</p>
<h1 id="对于自己调整自己的命令行程序举例"><a href="#对于自己调整自己的命令行程序举例" class="headerlink" title="对于自己调整自己的命令行程序举例:"></a>对于自己调整自己的命令行程序举例:</h1><p>在Console的子进程里自娱自乐是没用的, 必须让ConsoleWindow去做这事儿才有用。</p>
<p>具体的方法就是, 给ConsoleWindow一个事件, 指挥它改变键盘布局。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winuser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        HWND hCon = <span class="built_in">GetConsoleWindow</span>();</span><br><span class="line">        DWORD dwNewKeybLayout = <span class="number">0x00000409</span>; <span class="comment">// Layout must be already loaded!</span></span><br><span class="line">        <span class="built_in">PostMessage</span>(hCon, WM_INPUTLANGCHANGEREQUEST, <span class="number">0</span>, (LPARAM)dwNewKeybLayout);</span><br><span class="line">        <span class="built_in">PostMessage</span>(hCon, WM_INPUTLANGCHANGE, <span class="number">0</span>, (LPARAM)dwNewKeybLayout);</span><br><span class="line">        std::cin.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此法的原理可根据：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-inputlangchangerequest">WM_INPUTLANGCHANGEREQUEST message (Winuser.h) - Win32 apps | Microsoft Learn</a></p>
<p>得出。原理可根据文中一个例子轻易看出，在此简单地转述原文的意思：</p>
<p>一般来讲，手动点Tray切输入法，或者按Win+Space切换输入法时，操作系统会给所在焦点窗口发送该事件；窗口可以捕获并拒绝该事件，但也可置之不理，任凭转发给操作系统。这样就完成了输入法的切换。</p>
<p>转述完毕。</p>
<p>注意，此方法也有副作用，那就是此Console所在Window下的所有进程的KeyboardLayout都将受到波及。</p>
<h1 id="对于IMM的评论"><a href="#对于IMM的评论" class="headerlink" title="对于IMM的评论:"></a>对于IMM的评论:</h1><p>至于IMM, 经过我的研究, 它一般只能和当前IME做协作, 顶多切换全半角, 而对改变布局毫无帮助。</p>
<h1 id="其他有用的参考资料："><a href="#其他有用的参考资料：" class="headerlink" title="其他有用的参考资料："></a>其他有用的参考资料：</h1><p>此问答提供了代码中消息切输入法的思想：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49210290/loadkeyboardlayout-doesnt-change-keyboard-layout">c++ - LoadKeyboardLayout doesn’t change keyboard layout - Stack Overflow</a></p>
<p>此问答给出了IME的许多有益资料：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/434048/how-do-you-use-ime">windows - how do you use IME? - Stack Overflow</a></p>
<p>此博客给出了许多常见中文输入法的IMM API调用结果例子：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyl910/archive/2006/06/04/2186644.html">[Imm]Imm API学习笔记——输入法属性 - zyl910 - 博客园 (cnblogs.com)</a></p>
<p>此文档给出了IMM函数的列表，据说很多imm.h头文件里的签名没有在此罗列：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/intl/input-method-manager-functions">Input Method Manager Functions - Win32 apps | Microsoft Learn</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/ime-research/" data-id="clf0uds2s0000o0ju88vne5gg" data-title="Win10控制台应用IME研究" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-encoding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/encoding/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:39:26.672Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/encoding/">字符编码的历史与dotnet的做法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分裂时期的历史"><a href="#分裂时期的历史" class="headerlink" title="分裂时期的历史"></a>分裂时期的历史</h1><p><a target="_blank" rel="noopener" href="https://www.jb51.cc/python/3861798.html">国际化困境（第一篇） - 编程之家 (jb51.cc)</a></p>
<p>国人自创了GB2312编码，GB即拼音的“国标”，非英文也，GB2312是由我国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，基本集共收入汉字6763个和非汉字图形字符682个。GB2312在1995年的时候得到了一次扩展，汉字数增加到21003个，包括了我们所能看到的绝大多数的繁体字，甚至一些冷僻字（比如最近流行起来的“囧”字等），符号也增加到了883个，扩展后的GB2312被称为GBK码，（K是拼音“扩展”）当然你还是叫它“GB2312”也可以，或者叫它“GB码”都行，其实指的都是GBK，GBK也是最有影响力的中文编码，中文版的Windows 95就使用了它作为内码，即便到了Windows XP，你用记事本写一篇中文文章，默认的保存编码也是GBK码。关于GBK码，就先讲那么多，后面再详谈。日本也面临着这样的问题，所以他们也创建了自己的编码，叫“Shift-JIS”，和GBK码是不兼容的，台湾香港则是“Big5”码，和GBK码也不兼容，所以我们以前在DOS和Windows95环境下玩一些台湾开发的游戏软件时，总看到乱码。</p>
<h1 id="各个系统用的编码"><a href="#各个系统用的编码" class="headerlink" title="各个系统用的编码"></a>各个系统用的编码</h1><p>系统到底用的是什么code page，你到简体中文Windows下看看，你会发现ANSI code page和OEM code page都是936，即GBK，而日文的话则都是932（Shift-JIS），俄文则不同，ANSI code page和OEM code page分别是1251（西里尔文）和866（OEM俄文）。</p>
<h1 id="Unicode相关资料"><a href="#Unicode相关资料" class="headerlink" title="Unicode相关资料"></a>Unicode相关资料</h1><p>Python有篇文章, 对Unicode理解十分有益:</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/howto/unicode.html">Unicode HOWTO — Python 3.11.1 documentation</a></p>
<h1 id="dotnet转换编码方式"><a href="#dotnet转换编码方式" class="headerlink" title="dotnet转换编码方式"></a>dotnet转换编码方式</h1><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding">How to use character encoding classes in .NET | Microsoft Learn</a></p>
<p><code>System.Text.Encoding</code>是一个虚基类(即接口), 它底下的针对某编码的实现, 提供了GetBytes(<code>String-&gt;[Byte]</code>), GetChars(<code>String-&gt;[Byte]</code>)等等一系列方法.</p>
<p>对于ANSI那堆Code Page, 可以用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encoding enc = Encoding.GetEncoding(1253); Encoding altEnc = Encoding.GetEncoding(&quot;windows-1253&quot;); Console.WriteLine(&quot;&#123;0&#125; = Code;</span><br></pre></td></tr></table></figure>

<p>来得到此接口的某个实例.</p>
<p>当然, 在dotnet Core版本里, 事情貌似发生了变化:</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.text.codepagesencodingprovider?view=net-7.0">CodePagesEncodingProvider Class (System.Text) | Microsoft Learn</a></p>
<p>dotnetCore核心只支持Unicode编码, 那些CodePage现在得靠外挂一个额外的Class了.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CodePagesEncodingProvider</span> : <span class="title">System.Text.EncodingProvider</span></span><br></pre></td></tr></table></figure>

<p>转述摘抄doc原文如下:</p>
<p>The .NET Framework for the Windows desktop supports a large set of Unicode and code page encodings. .NET Core, on the other hand, supports only the following encodings:</p>
<p>The .NET Framework for the Windows desktop supports a large set of Unicode and code page encodings. .NET Core, on the other hand, supports only the following encodings:</p>
<h1 id="Python编码转换方式"><a href="#Python编码转换方式" class="headerlink" title="Python编码转换方式"></a>Python编码转换方式</h1><p>请参见:<br><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/codecs.html#standard-encodings">codecs — Codec registry and base classes — Python 3.11.1 documentation</a></p>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;\xfe\x87&#x27;.decode(&#x27;gbk&#x27;)</span><br><span class="line">&#x27;某某&#x27;.encode(&#x27;gbk&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="乱码的原理和排查原理分析-以及有益的表格"><a href="#乱码的原理和排查原理分析-以及有益的表格" class="headerlink" title="乱码的原理和排查原理分析, 以及有益的表格"></a>乱码的原理和排查原理分析, 以及有益的表格</h1><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我在draw.io上画了图.</p>
<p>这是截的图:</p>
<p>![[Pasted image 20230203002614.png|300]]</p>
<p>这是保存的SVG:</p>
<p>![[luanma.svg.svg]]</p>
<p>是这样的, Windows NT里字体的显示是用Unicode的码表来显示的.</p>
<p>圆点则代表本来的”Bytes数组”</p>
<p>当我们说”乱码”时, 我们其实是在说: 一个本来正确的表示, 在走了长度为2的路径后, 变成了奇怪的表示.</p>
<p>其中, 路径就是图中的箭头, 代表一次编解码, 即一次转换. 而且这转换还往往不是单元的(identity)(考虑UTF16转成UTF16编码, 这就是identity的转换)</p>
<p>所以, 为了识别出乱码的路径, 在已知原先含义, 以及乱码这两个信息的情况下, 需要行走长度为2的路径, 才能找出错误原因.</p>
<h2 id="有益的排查表"><a href="#有益的排查表" class="headerlink" title="有益的排查表"></a>有益的排查表</h2><p>其实ISO8859-1就是Latin1, 西欧字符集.</p>
<p>![[Pasted image 20230203004100.png]]</p>
<p>归纳如下:</p>
<table>
<thead>
<tr>
<th align="right">类型&#x2F;路径次序</th>
<th align="center">1下行</th>
<th align="center">2上行</th>
<th align="center">3下行</th>
<th align="center">4上行</th>
</tr>
</thead>
<tbody><tr>
<td align="right">古文码</td>
<td align="center">u8</td>
<td align="center">GBK</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">口字码</td>
<td align="center">GBK</td>
<td align="center">u8</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">符号码</td>
<td align="center">u8</td>
<td align="center">Lat</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">问句码</td>
<td align="center">u8</td>
<td align="center">GBK</td>
<td align="center">GBK</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="right">锟拷码</td>
<td align="center">GBK</td>
<td align="center">u8</td>
<td align="center">u8</td>
<td align="center">GBK</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/encoding/" data-id="clesiwdl80000iwju1u6iebvq" data-title="字符编码的历史与dotnet的做法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-saga-agenda" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/saga-agenda/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:38:03.555Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/saga-agenda/">YouTube Saga视频的Agenda</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Agenda [<span class="number">3</span>:<span class="number">58</span>]</span><br><span class="line">ACID is not an option [<span class="number">5</span>:<span class="number">04</span>]</span><br><span class="line">  (<span class="name">Scenario:</span> Customer has a credit limit) [<span class="number">5</span>:<span class="number">13</span>]</span><br><span class="line">  Transactions in a monolithic architecture [<span class="number">5</span>:<span class="number">58</span>]</span><br><span class="line">    Concurrent transaction for the same customer will be serialized [<span class="number">7</span>:<span class="number">15</span>]</span><br><span class="line">  Microservices [<span class="number">9</span>:<span class="number">00</span>]</span><br><span class="line">  Microservice architecture [<span class="number">10</span>:<span class="number">30</span>]</span><br><span class="line">  Loose coupling = encapsulated data [<span class="number">11</span>:<span class="number">13</span>]</span><br><span class="line">  <span class="number">2</span>PC is not an option [<span class="number">13</span>:<span class="number">41</span>]</span><br><span class="line">Overview of sagas [<span class="number">15</span>:<span class="number">01</span>]</span><br><span class="line">  Use Sagas instead of <span class="number">2</span>PC [<span class="number">15</span>:<span class="number">14</span>]</span><br><span class="line">  Create Order Saga [<span class="number">16</span>:<span class="number">22</span>]</span><br><span class="line">  Rollback using compensating transactions [<span class="number">18</span>:<span class="number">20</span>]</span><br><span class="line">  Saga: Every Ti has a Ci [<span class="number">19</span>:<span class="number">0</span><span class="number">8</span>]</span><br><span class="line">  Create Order Saga - rollback [<span class="number">20</span>:<span class="number">30</span>]</span><br><span class="line">  Sagas complicate API design [<span class="number">22</span>:<span class="number">03</span>]</span><br><span class="line">    Request initiate the saga. When to send back the response?</span><br><span class="line">    Option #<span class="number">1</span>: Send response when saga completes</span><br><span class="line">    - Response specifies the outcome</span><br><span class="line">    - Reduced availability</span><br><span class="line">    Option #<span class="number">2</span>: Send response immediately after creating the saga (<span class="name">recommended</span>)</span><br><span class="line">    - Improved availability</span><br><span class="line">    - Response does not specify the outcome. Client must poll or be notified</span><br><span class="line">  Revised Create Order API [<span class="number">24</span>:<span class="number">41</span>]</span><br><span class="line">    createOrder()</span><br><span class="line">      returns id of newly created order</span><br><span class="line">      NOT fully validated</span><br><span class="line">    getOrder(<span class="name">id</span>)</span><br><span class="line">      called periodically by client to get outcome of validation</span><br><span class="line">  Minimal impact on UI [<span class="number">25</span>:<span class="number">22</span>]</span><br><span class="line">    UI hides asynchronous API from the user</span><br><span class="line">    Saga will usually appear instantaneous (<span class="name"><span class="built_in">&lt;=</span></span> <span class="number">100</span>ms)</span><br><span class="line">    If it takes longer =&gt; UI displays <span class="string">&quot;processing&quot;</span> popup</span><br><span class="line">    Server can push notification to UI</span><br><span class="line">  Sagas complicate the business logic [<span class="number">26</span>:<span class="number">33</span>]</span><br><span class="line">Coordinating sagas [<span class="number">28</span>:<span class="number">33</span>]</span><br><span class="line">  How to sequence the saga transactions? [<span class="number">28</span>:<span class="number">41</span>]</span><br><span class="line">    After the completion of transaction Ti <span class="string">&quot;something&quot;</span> must decide what step to execute next</span><br><span class="line">    Success: which T(<span class="name">i+1</span>) - branching</span><br><span class="line">    Failure: C(<span class="name">i-1</span>)</span><br><span class="line">  Option#<span class="number">1</span>: Choreography-based coordination (<span class="name">distributed</span>) [<span class="number">29</span>:<span class="number">45</span>]</span><br><span class="line">  Option#<span class="number">2</span>: Orchestration-based coordination (<span class="name">centralized</span>) [<span class="number">30</span>:<span class="number">16</span>]</span><br><span class="line">  Saga orchestrators are state machines [<span class="number">30</span>:<span class="number">48</span>]</span><br><span class="line">  Implicit vs. explicit orchestrator [<span class="number">31</span>:<span class="number">47</span>]</span><br><span class="line">  Event-based<span class="punctuation">,</span> implicit orchestrator [<span class="number">32</span>:<span class="number">38</span>]</span><br><span class="line">  Explicit orchestration [<span class="number">34</span>:<span class="number">05</span>]</span><br><span class="line">  Create Order Saga (<span class="name">code</span> sample) [<span class="number">35</span>:<span class="number">12</span>]</span><br><span class="line">    Initializing the saga [<span class="number">37</span>:<span class="number">20</span>]</span><br><span class="line">    Handling a reply [<span class="number">37</span>:<span class="number">58</span>]</span><br><span class="line">    Customer Service - command handling [<span class="number">38</span>:<span class="number">28</span>]</span><br><span class="line">Transactional messaging [<span class="number">39</span>:<span class="number">18</span>]</span><br><span class="line">  About Saga orchestrator ⇔ participant communication [<span class="number">39</span>:<span class="number">22</span>]</span><br><span class="line">  Messaging channels [<span class="number">40</span>:<span class="number">52</span>]</span><br><span class="line">  Create Order Saga messaging [<span class="number">41</span>:<span class="number">31</span>]</span><br><span class="line">  Messaging must be transactional [<span class="number">41</span>:<span class="number">59</span>]</span><br><span class="line">  <span class="number">2</span>PC still isn&#x27;t an option [<span class="number">43</span>:<span class="number">06</span>]</span><br><span class="line">  Use database table as a message queue [<span class="number">43</span>:<span class="number">22</span>]</span><br><span class="line">  Publishing message using polling [<span class="number">44</span>:<span class="number">33</span>]</span><br><span class="line">  Transaction log tailing [<span class="number">46</span>:<span class="number">17</span>]</span><br><span class="line">  About transaction log tailing [<span class="number">46</span>:<span class="number">57</span>]</span><br><span class="line">    MySQL master-slave replication protocol</span><br><span class="line">    DynamoDB table streams</span><br><span class="line">Summary [<span class="number">48</span>:<span class="number">13</span>]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/saga-agenda/" data-id="clesiwdlc0002iwjuakigdsk4" data-title="YouTube Saga视频的Agenda" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-jboss" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/jboss/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:37:16.787Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/jboss/">JBoss社区好的东西</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JBoss-Seam"><a href="#JBoss-Seam" class="headerlink" title="JBoss Seam"></a>JBoss Seam</h1><p>曾经不错, 但现在没人用了.</p>
<p>和JBoss、ibm WebSphere was、 WebLogic并称的.</p>
<p>我的观点是：Jboss包括现在的wildfly在技术上是先进的，甚至要好于weblogic和websphare，但是，在理念上已经过时或者错误。</p>
<h2 id="一篇介绍"><a href="#一篇介绍" class="headerlink" title="一篇介绍"></a>一篇介绍</h2><p>作者：千锋Java学习站<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/50665320/answer/885551650">https://www.zhihu.com/question/50665320/answer/885551650</a>  </p>
<p>说到服务器，不得不提tomcat，也是现在目前很多中小型项目中喜欢使用的服务器，当然在web应用中也称之为容器，tomcat是典型的servlet容器，针对传统的servlet规范的应用来说，tomcat足矣，&#x3D;&#x3D;但是javaee推出的不只是servlet规范，还推出了jpa，ejb等各种规范，如果基于这些规范的应用，tomcat明显不够用&#x3D;&#x3D;，于是像JBoss、WebSphere、WebLogic等javaEE全栈型服务器便可派上用场了。</p>
<p>JBoss是一款开源的应用服务器，是过去很多大型项目的应用服务器，&#x3D;&#x3D;本身支持EJB规范和集群，能够集成tomcat等servlet容器&#x3D;&#x3D;，但因其&#x3D;&#x3D;性能上的缺陷&#x3D;&#x3D;，被很多项目放弃，不过现版本已被RedHat作为企业级应用平台的上游基础服务器并更名为WildFly，启动效率更高，更加轻量级，所以更名为WildFly以后，很多企业级的大型应用，如：ERP，SOA系统应用都喜欢发布在WildFly也就是JBoss应用服务器上。</p>
<p>WebSphere是IBM电子商务业务平台上所推出的一款应用服务器，集成了web服务的所有资源，同时也可以对Apache、IIS等其他应用服务器形成协同并拓展。和JBoss的集成性大差不差，但是其并不免费，所以其安全性上能够相对JBoss更有保证，所以往往&#x3D;&#x3D;银行，金融类的大型应用&#x3D;&#x3D;都会应用在WebSphere服务器上。</p>
<p>WebLogic是现如今EJB分布式应用领域中排名第一的应用服务器，相对与JBoss来说，无论在&#x3D;&#x3D;集群管理&#x3D;&#x3D;上还是热部署处理上，WebLogic都更加的稳定，相对于WebSphere来说配置更加的简单，而且&#x3D;&#x3D;支持对JSP的扩展，支持JHTML，&#x3D;&#x3D;技术也相对WebSphere更加成熟，市场占有率上也不是WebSphere所能竞争的，所以现如今很多大型的企业级分布式应用都会使用WebLogic。</p>
<h1 id="wildfly"><a href="#wildfly" class="headerlink" title="wildfly"></a>wildfly</h1><p>是JBoss改名后的开源版本. 现在在红帽麾下.</p>
<p>更加轻量与快了, 但貌似也没人用. GitHub现在2.8k Star. 但这玩意儿官方文档的图怎么都挂了? 难顶.</p>
<ul>
<li>名词解释</li>
<li>EJB, Enterprise Bean, 一种远古复杂的J2EE Bean规范.</li>
<li>POJO(即普通的, 不带IO和业务逻辑的Java Bean).</li>
<li>JSF, Java Server Faces技术（一种基于服务器端的技术）</li>
</ul>
<p>很多人把它与Spring MVC做比. 它有DI, 有网页模板(好像叫JSF), 好像用到了Ajax相关技术, 还有EJB. 但它也能不用EJB, 而是用POJO)</p>
<p>我下载了一本书<code>Beginning JSF™ 2 APIs and JBoss® Seam (Experts Voice in Java) (Kent Ka Iok Tong) (Z-Library).pdf</code>. 看了里面的示例, 看样子它在Server维护了一颗视图树, 走的是传统GUI的路子.</p>
<p>这是否有点像<strong>C# Blazor</strong>那套? 只不过Seam用的是Ajax, Blazor用的是更现代的Web Assembly或者WebSocket. 我靠.</p>
<h1 id="jboss社区别的项目"><a href="#jboss社区别的项目" class="headerlink" title="jboss社区别的项目"></a>jboss社区别的项目</h1><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>是个不错网络通讯的框架，如果你做手机socket通讯，建议你看看这个。</p>
<p>其实就是个事件驱动的Reactor框架.</p>
<h2 id="jgroups"><a href="#jgroups" class="headerlink" title="jgroups"></a>jgroups</h2><p>是个主要UDP通信的框架，如果你做局域网里的数据通讯建议你看看这个。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/jboss/" data-id="clesiwdla0001iwju3v9pa1b9" data-title="JBoss社区好的东西" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hexo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/hexo/" class="article-date">
  <time class="dt-published" datetime="2023-03-02T16:00:00.000Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%8F%82%E8%80%83/">软件参考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/hexo/">Hexo参考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这些命令应该有所帮助:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo -h</span><br><span class="line">hexo d</span><br><span class="line">hexo g</span><br><span class="line">hexo d -g</span><br><span class="line"><span class="built_in">cat</span> (Get-PSReadlineOption).HistorySavePath | select-something hexo</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/hexo/" data-id="clcqfyx7e000138jubbh98da9" data-title="Hexo参考" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/OO%E8%AE%BE%E8%AE%A1/">OO设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/">编译链接</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/OO%E8%AE%BE%E8%AE%A1/">OO设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%8F%82%E8%80%83/">软件参考</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/OpenGL/" style="font-size: 10px;">OpenGL</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/haskell/" style="font-size: 10px;">haskell</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%9D%82%E6%84%9F/" style="font-size: 16.67px;">杂感</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 13.33px;">编码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/memento/">Memento模式实现角色状态恢复</a>
          </li>
        
          <li>
            <a href="/2023/09/05/proactor-messageblock/">ACE用Proactor与Message Block、Queue处理分包、粘包</a>
          </li>
        
          <li>
            <a href="/2023/09/04/header-only-lib/">C++将项目改造成纯头文件库</a>
          </li>
        
          <li>
            <a href="/2023/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/effective-cpp-24/">Effective C++ 条款23：多用non member函数</a>
          </li>
        
          <li>
            <a href="/2023/03/09/dynamic-cast/">dynamic_cast与虚继承</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Master Turtle<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>