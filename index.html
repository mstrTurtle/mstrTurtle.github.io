<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>mstrTurtle的生活智慧</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="mstrTurtle的生活智慧">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="mstrTurtle的生活智慧">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Master Turtle">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="mstrTurtle的生活智慧" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mstrTurtle的生活智慧</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ime-research" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/ime-research/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:47:44.513Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/ime-research/">Win10控制台应用IME研究</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>源自我的知乎回答: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/381963138/answer/2876498622">win10如何切换输入法？</a></p>
<p>如何用全局快捷键, 切换到指定输入法? 一种思路是用窗口事件，另一种是ActivateKeyboardLayout。后者有待研究, 但至少前者是管用的，并将在下文叙述。</p>
<p>在下文所述切输入法方法的基础上，加以完善，就能实现完整可用的程序。具体的完善方法为：写一个后台服务, 捕获全局快捷键, 获得当前焦点窗口的hWnd, 然后按下文所述方法，给它发切输入法的消息。</p>
<h1 id="概念说明："><a href="#概念说明：" class="headerlink" title="概念说明："></a>概念说明：</h1><p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://support.microsoft.com/en-us/windows/manage-the-input-and-display-language-settings-in-windows-12a10cb4-8626-9b77-0ccb-5013e0c7c7a2#:~:text=To%20switch%20the%20keyboard%20layout%20you%27re%20using%20in%20Windows,through%20all%20your%20installed%20keyboards.">Manage the input and display language settings in Windows - Microsoft Support</a></p>
<p>得出，KeyboardLayout指Tray里的方框。</p>
<p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/dxtecharts/using-an-input-method-editor-in-a-game">Using an Input Method Editor in a Game - Win32 apps | Microsoft Learn</a></p>
<p>得出，此方框也叫Input Locale Indicator。</p>
<p>根据：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/intl/about-input-method-manager">About Input Method Manager - Win32 apps | Microsoft Learn</a></p>
<p>IMM只在安装了东亚Locale时，才会启用；IMM会创造IME。</p>
<h1 id="对于自己调整自己的命令行程序举例"><a href="#对于自己调整自己的命令行程序举例" class="headerlink" title="对于自己调整自己的命令行程序举例:"></a>对于自己调整自己的命令行程序举例:</h1><p>在Console的子进程里自娱自乐是没用的, 必须让ConsoleWindow去做这事儿才有用。</p>
<p>具体的方法就是, 给ConsoleWindow一个事件, 指挥它改变键盘布局。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winuser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        HWND hCon = <span class="built_in">GetConsoleWindow</span>();</span><br><span class="line">        DWORD dwNewKeybLayout = <span class="number">0x00000409</span>; <span class="comment">// Layout must be already loaded!</span></span><br><span class="line">        <span class="built_in">PostMessage</span>(hCon, WM_INPUTLANGCHANGEREQUEST, <span class="number">0</span>, (LPARAM)dwNewKeybLayout);</span><br><span class="line">        <span class="built_in">PostMessage</span>(hCon, WM_INPUTLANGCHANGE, <span class="number">0</span>, (LPARAM)dwNewKeybLayout);</span><br><span class="line">        std::cin.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此法的原理可根据：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/winmsg/wm-inputlangchangerequest">WM_INPUTLANGCHANGEREQUEST message (Winuser.h) - Win32 apps | Microsoft Learn</a></p>
<p>得出。原理可根据文中一个例子轻易看出，在此简单地转述原文的意思：</p>
<p>一般来讲，手动点Tray切输入法，或者按Win+Space切换输入法时，操作系统会给所在焦点窗口发送该事件；窗口可以捕获并拒绝该事件，但也可置之不理，任凭转发给操作系统。这样就完成了输入法的切换。</p>
<p>转述完毕。</p>
<p>注意，此方法也有副作用，那就是此Console所在Window下的所有进程的KeyboardLayout都将受到波及。</p>
<h1 id="对于IMM的评论"><a href="#对于IMM的评论" class="headerlink" title="对于IMM的评论:"></a>对于IMM的评论:</h1><p>至于IMM, 经过我的研究, 它一般只能和当前IME做协作, 顶多切换全半角, 而对改变布局毫无帮助。</p>
<h1 id="其他有用的参考资料："><a href="#其他有用的参考资料：" class="headerlink" title="其他有用的参考资料："></a>其他有用的参考资料：</h1><p>此问答提供了代码中消息切输入法的思想：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49210290/loadkeyboardlayout-doesnt-change-keyboard-layout">c++ - LoadKeyboardLayout doesn’t change keyboard layout - Stack Overflow</a></p>
<p>此问答给出了IME的许多有益资料：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/434048/how-do-you-use-ime">windows - how do you use IME? - Stack Overflow</a></p>
<p>此博客给出了许多常见中文输入法的IMM API调用结果例子：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyl910/archive/2006/06/04/2186644.html">[Imm]Imm API学习笔记——输入法属性 - zyl910 - 博客园 (cnblogs.com)</a></p>
<p>此文档给出了IMM函数的列表，据说很多imm.h头文件里的签名没有在此罗列：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/intl/input-method-manager-functions">Input Method Manager Functions - Win32 apps | Microsoft Learn</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/ime-research/" data-id="clf0uds2s0000o0ju88vne5gg" data-title="Win10控制台应用IME研究" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-encoding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/encoding/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:39:26.672Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/encoding/">字符编码的历史与dotnet的做法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分裂时期的历史"><a href="#分裂时期的历史" class="headerlink" title="分裂时期的历史"></a>分裂时期的历史</h1><p><a target="_blank" rel="noopener" href="https://www.jb51.cc/python/3861798.html">国际化困境（第一篇） - 编程之家 (jb51.cc)</a></p>
<p>国人自创了GB2312编码，GB即拼音的“国标”，非英文也，GB2312是由我国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，基本集共收入汉字6763个和非汉字图形字符682个。GB2312在1995年的时候得到了一次扩展，汉字数增加到21003个，包括了我们所能看到的绝大多数的繁体字，甚至一些冷僻字（比如最近流行起来的“囧”字等），符号也增加到了883个，扩展后的GB2312被称为GBK码，（K是拼音“扩展”）当然你还是叫它“GB2312”也可以，或者叫它“GB码”都行，其实指的都是GBK，GBK也是最有影响力的中文编码，中文版的Windows 95就使用了它作为内码，即便到了Windows XP，你用记事本写一篇中文文章，默认的保存编码也是GBK码。关于GBK码，就先讲那么多，后面再详谈。日本也面临着这样的问题，所以他们也创建了自己的编码，叫“Shift-JIS”，和GBK码是不兼容的，台湾香港则是“Big5”码，和GBK码也不兼容，所以我们以前在DOS和Windows95环境下玩一些台湾开发的游戏软件时，总看到乱码。</p>
<h1 id="各个系统用的编码"><a href="#各个系统用的编码" class="headerlink" title="各个系统用的编码"></a>各个系统用的编码</h1><p>系统到底用的是什么code page，你到简体中文Windows下看看，你会发现ANSI code page和OEM code page都是936，即GBK，而日文的话则都是932（Shift-JIS），俄文则不同，ANSI code page和OEM code page分别是1251（西里尔文）和866（OEM俄文）。</p>
<h1 id="Unicode相关资料"><a href="#Unicode相关资料" class="headerlink" title="Unicode相关资料"></a>Unicode相关资料</h1><p>Python有篇文章, 对Unicode理解十分有益:</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/howto/unicode.html">Unicode HOWTO — Python 3.11.1 documentation</a></p>
<h1 id="dotnet转换编码方式"><a href="#dotnet转换编码方式" class="headerlink" title="dotnet转换编码方式"></a>dotnet转换编码方式</h1><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding">How to use character encoding classes in .NET | Microsoft Learn</a></p>
<p><code>System.Text.Encoding</code>是一个虚基类(即接口), 它底下的针对某编码的实现, 提供了GetBytes(<code>String-&gt;[Byte]</code>), GetChars(<code>String-&gt;[Byte]</code>)等等一系列方法.</p>
<p>对于ANSI那堆Code Page, 可以用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encoding enc = Encoding.GetEncoding(1253); Encoding altEnc = Encoding.GetEncoding(&quot;windows-1253&quot;); Console.WriteLine(&quot;&#123;0&#125; = Code;</span><br></pre></td></tr></table></figure>

<p>来得到此接口的某个实例.</p>
<p>当然, 在dotnet Core版本里, 事情貌似发生了变化:</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.text.codepagesencodingprovider?view=net-7.0">CodePagesEncodingProvider Class (System.Text) | Microsoft Learn</a></p>
<p>dotnetCore核心只支持Unicode编码, 那些CodePage现在得靠外挂一个额外的Class了.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CodePagesEncodingProvider</span> : <span class="title">System.Text.EncodingProvider</span></span><br></pre></td></tr></table></figure>

<p>转述摘抄doc原文如下:</p>
<p>The .NET Framework for the Windows desktop supports a large set of Unicode and code page encodings. .NET Core, on the other hand, supports only the following encodings:</p>
<p>The .NET Framework for the Windows desktop supports a large set of Unicode and code page encodings. .NET Core, on the other hand, supports only the following encodings:</p>
<h1 id="Python编码转换方式"><a href="#Python编码转换方式" class="headerlink" title="Python编码转换方式"></a>Python编码转换方式</h1><p>请参见:<br><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/codecs.html#standard-encodings">codecs — Codec registry and base classes — Python 3.11.1 documentation</a></p>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;\xfe\x87&#x27;.decode(&#x27;gbk&#x27;)</span><br><span class="line">&#x27;某某&#x27;.encode(&#x27;gbk&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="乱码的原理和排查原理分析-以及有益的表格"><a href="#乱码的原理和排查原理分析-以及有益的表格" class="headerlink" title="乱码的原理和排查原理分析, 以及有益的表格"></a>乱码的原理和排查原理分析, 以及有益的表格</h1><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我在draw.io上画了图.</p>
<p>这是截的图:</p>
<p>![[Pasted image 20230203002614.png|300]]</p>
<p>这是保存的SVG:</p>
<p>![[luanma.svg.svg]]</p>
<p>是这样的, Windows NT里字体的显示是用Unicode的码表来显示的.</p>
<p>圆点则代表本来的”Bytes数组”</p>
<p>当我们说”乱码”时, 我们其实是在说: 一个本来正确的表示, 在走了长度为2的路径后, 变成了奇怪的表示.</p>
<p>其中, 路径就是图中的箭头, 代表一次编解码, 即一次转换. 而且这转换还往往不是单元的(identity)(考虑UTF16转成UTF16编码, 这就是identity的转换)</p>
<p>所以, 为了识别出乱码的路径, 在已知原先含义, 以及乱码这两个信息的情况下, 需要行走长度为2的路径, 才能找出错误原因.</p>
<h2 id="有益的排查表"><a href="#有益的排查表" class="headerlink" title="有益的排查表"></a>有益的排查表</h2><p>其实ISO8859-1就是Latin1, 西欧字符集.</p>
<p>![[Pasted image 20230203004100.png]]</p>
<p>归纳如下:</p>
<table>
<thead>
<tr>
<th align="right">类型&#x2F;路径次序</th>
<th align="center">1下行</th>
<th align="center">2上行</th>
<th align="center">3下行</th>
<th align="center">4上行</th>
</tr>
</thead>
<tbody><tr>
<td align="right">古文码</td>
<td align="center">u8</td>
<td align="center">GBK</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">口字码</td>
<td align="center">GBK</td>
<td align="center">u8</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">符号码</td>
<td align="center">u8</td>
<td align="center">Lat</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">问句码</td>
<td align="center">u8</td>
<td align="center">GBK</td>
<td align="center">GBK</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="right">锟拷码</td>
<td align="center">GBK</td>
<td align="center">u8</td>
<td align="center">u8</td>
<td align="center">GBK</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/encoding/" data-id="clesiwdl80000iwju1u6iebvq" data-title="字符编码的历史与dotnet的做法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-saga-agenda" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/saga-agenda/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:38:03.555Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/saga-agenda/">YouTube Saga视频的Agenda</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Agenda [<span class="number">3</span>:<span class="number">58</span>]</span><br><span class="line">ACID is not an option [<span class="number">5</span>:<span class="number">04</span>]</span><br><span class="line">  (<span class="name">Scenario:</span> Customer has a credit limit) [<span class="number">5</span>:<span class="number">13</span>]</span><br><span class="line">  Transactions in a monolithic architecture [<span class="number">5</span>:<span class="number">58</span>]</span><br><span class="line">    Concurrent transaction for the same customer will be serialized [<span class="number">7</span>:<span class="number">15</span>]</span><br><span class="line">  Microservices [<span class="number">9</span>:<span class="number">00</span>]</span><br><span class="line">  Microservice architecture [<span class="number">10</span>:<span class="number">30</span>]</span><br><span class="line">  Loose coupling = encapsulated data [<span class="number">11</span>:<span class="number">13</span>]</span><br><span class="line">  <span class="number">2</span>PC is not an option [<span class="number">13</span>:<span class="number">41</span>]</span><br><span class="line">Overview of sagas [<span class="number">15</span>:<span class="number">01</span>]</span><br><span class="line">  Use Sagas instead of <span class="number">2</span>PC [<span class="number">15</span>:<span class="number">14</span>]</span><br><span class="line">  Create Order Saga [<span class="number">16</span>:<span class="number">22</span>]</span><br><span class="line">  Rollback using compensating transactions [<span class="number">18</span>:<span class="number">20</span>]</span><br><span class="line">  Saga: Every Ti has a Ci [<span class="number">19</span>:<span class="number">0</span><span class="number">8</span>]</span><br><span class="line">  Create Order Saga - rollback [<span class="number">20</span>:<span class="number">30</span>]</span><br><span class="line">  Sagas complicate API design [<span class="number">22</span>:<span class="number">03</span>]</span><br><span class="line">    Request initiate the saga. When to send back the response?</span><br><span class="line">    Option #<span class="number">1</span>: Send response when saga completes</span><br><span class="line">    - Response specifies the outcome</span><br><span class="line">    - Reduced availability</span><br><span class="line">    Option #<span class="number">2</span>: Send response immediately after creating the saga (<span class="name">recommended</span>)</span><br><span class="line">    - Improved availability</span><br><span class="line">    - Response does not specify the outcome. Client must poll or be notified</span><br><span class="line">  Revised Create Order API [<span class="number">24</span>:<span class="number">41</span>]</span><br><span class="line">    createOrder()</span><br><span class="line">      returns id of newly created order</span><br><span class="line">      NOT fully validated</span><br><span class="line">    getOrder(<span class="name">id</span>)</span><br><span class="line">      called periodically by client to get outcome of validation</span><br><span class="line">  Minimal impact on UI [<span class="number">25</span>:<span class="number">22</span>]</span><br><span class="line">    UI hides asynchronous API from the user</span><br><span class="line">    Saga will usually appear instantaneous (<span class="name"><span class="built_in">&lt;=</span></span> <span class="number">100</span>ms)</span><br><span class="line">    If it takes longer =&gt; UI displays <span class="string">&quot;processing&quot;</span> popup</span><br><span class="line">    Server can push notification to UI</span><br><span class="line">  Sagas complicate the business logic [<span class="number">26</span>:<span class="number">33</span>]</span><br><span class="line">Coordinating sagas [<span class="number">28</span>:<span class="number">33</span>]</span><br><span class="line">  How to sequence the saga transactions? [<span class="number">28</span>:<span class="number">41</span>]</span><br><span class="line">    After the completion of transaction Ti <span class="string">&quot;something&quot;</span> must decide what step to execute next</span><br><span class="line">    Success: which T(<span class="name">i+1</span>) - branching</span><br><span class="line">    Failure: C(<span class="name">i-1</span>)</span><br><span class="line">  Option#<span class="number">1</span>: Choreography-based coordination (<span class="name">distributed</span>) [<span class="number">29</span>:<span class="number">45</span>]</span><br><span class="line">  Option#<span class="number">2</span>: Orchestration-based coordination (<span class="name">centralized</span>) [<span class="number">30</span>:<span class="number">16</span>]</span><br><span class="line">  Saga orchestrators are state machines [<span class="number">30</span>:<span class="number">48</span>]</span><br><span class="line">  Implicit vs. explicit orchestrator [<span class="number">31</span>:<span class="number">47</span>]</span><br><span class="line">  Event-based<span class="punctuation">,</span> implicit orchestrator [<span class="number">32</span>:<span class="number">38</span>]</span><br><span class="line">  Explicit orchestration [<span class="number">34</span>:<span class="number">05</span>]</span><br><span class="line">  Create Order Saga (<span class="name">code</span> sample) [<span class="number">35</span>:<span class="number">12</span>]</span><br><span class="line">    Initializing the saga [<span class="number">37</span>:<span class="number">20</span>]</span><br><span class="line">    Handling a reply [<span class="number">37</span>:<span class="number">58</span>]</span><br><span class="line">    Customer Service - command handling [<span class="number">38</span>:<span class="number">28</span>]</span><br><span class="line">Transactional messaging [<span class="number">39</span>:<span class="number">18</span>]</span><br><span class="line">  About Saga orchestrator ⇔ participant communication [<span class="number">39</span>:<span class="number">22</span>]</span><br><span class="line">  Messaging channels [<span class="number">40</span>:<span class="number">52</span>]</span><br><span class="line">  Create Order Saga messaging [<span class="number">41</span>:<span class="number">31</span>]</span><br><span class="line">  Messaging must be transactional [<span class="number">41</span>:<span class="number">59</span>]</span><br><span class="line">  <span class="number">2</span>PC still isn&#x27;t an option [<span class="number">43</span>:<span class="number">06</span>]</span><br><span class="line">  Use database table as a message queue [<span class="number">43</span>:<span class="number">22</span>]</span><br><span class="line">  Publishing message using polling [<span class="number">44</span>:<span class="number">33</span>]</span><br><span class="line">  Transaction log tailing [<span class="number">46</span>:<span class="number">17</span>]</span><br><span class="line">  About transaction log tailing [<span class="number">46</span>:<span class="number">57</span>]</span><br><span class="line">    MySQL master-slave replication protocol</span><br><span class="line">    DynamoDB table streams</span><br><span class="line">Summary [<span class="number">48</span>:<span class="number">13</span>]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/saga-agenda/" data-id="clesiwdlc0002iwjuakigdsk4" data-title="YouTube Saga视频的Agenda" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-jboss" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/jboss/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T12:37:16.787Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/jboss/">JBoss社区好的东西</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JBoss-Seam"><a href="#JBoss-Seam" class="headerlink" title="JBoss Seam"></a>JBoss Seam</h1><p>曾经不错, 但现在没人用了.</p>
<p>和JBoss、ibm WebSphere was、 WebLogic并称的.</p>
<p>我的观点是：Jboss包括现在的wildfly在技术上是先进的，甚至要好于weblogic和websphare，但是，在理念上已经过时或者错误。</p>
<h2 id="一篇介绍"><a href="#一篇介绍" class="headerlink" title="一篇介绍"></a>一篇介绍</h2><p>作者：千锋Java学习站<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/50665320/answer/885551650">https://www.zhihu.com/question/50665320/answer/885551650</a>  </p>
<p>说到服务器，不得不提tomcat，也是现在目前很多中小型项目中喜欢使用的服务器，当然在web应用中也称之为容器，tomcat是典型的servlet容器，针对传统的servlet规范的应用来说，tomcat足矣，&#x3D;&#x3D;但是javaee推出的不只是servlet规范，还推出了jpa，ejb等各种规范，如果基于这些规范的应用，tomcat明显不够用&#x3D;&#x3D;，于是像JBoss、WebSphere、WebLogic等javaEE全栈型服务器便可派上用场了。</p>
<p>JBoss是一款开源的应用服务器，是过去很多大型项目的应用服务器，&#x3D;&#x3D;本身支持EJB规范和集群，能够集成tomcat等servlet容器&#x3D;&#x3D;，但因其&#x3D;&#x3D;性能上的缺陷&#x3D;&#x3D;，被很多项目放弃，不过现版本已被RedHat作为企业级应用平台的上游基础服务器并更名为WildFly，启动效率更高，更加轻量级，所以更名为WildFly以后，很多企业级的大型应用，如：ERP，SOA系统应用都喜欢发布在WildFly也就是JBoss应用服务器上。</p>
<p>WebSphere是IBM电子商务业务平台上所推出的一款应用服务器，集成了web服务的所有资源，同时也可以对Apache、IIS等其他应用服务器形成协同并拓展。和JBoss的集成性大差不差，但是其并不免费，所以其安全性上能够相对JBoss更有保证，所以往往&#x3D;&#x3D;银行，金融类的大型应用&#x3D;&#x3D;都会应用在WebSphere服务器上。</p>
<p>WebLogic是现如今EJB分布式应用领域中排名第一的应用服务器，相对与JBoss来说，无论在&#x3D;&#x3D;集群管理&#x3D;&#x3D;上还是热部署处理上，WebLogic都更加的稳定，相对于WebSphere来说配置更加的简单，而且&#x3D;&#x3D;支持对JSP的扩展，支持JHTML，&#x3D;&#x3D;技术也相对WebSphere更加成熟，市场占有率上也不是WebSphere所能竞争的，所以现如今很多大型的企业级分布式应用都会使用WebLogic。</p>
<h1 id="wildfly"><a href="#wildfly" class="headerlink" title="wildfly"></a>wildfly</h1><p>是JBoss改名后的开源版本. 现在在红帽麾下.</p>
<p>更加轻量与快了, 但貌似也没人用. GitHub现在2.8k Star. 但这玩意儿官方文档的图怎么都挂了? 难顶.</p>
<ul>
<li>名词解释</li>
<li>EJB, Enterprise Bean, 一种远古复杂的J2EE Bean规范.</li>
<li>POJO(即普通的, 不带IO和业务逻辑的Java Bean).</li>
<li>JSF, Java Server Faces技术（一种基于服务器端的技术）</li>
</ul>
<p>很多人把它与Spring MVC做比. 它有DI, 有网页模板(好像叫JSF), 好像用到了Ajax相关技术, 还有EJB. 但它也能不用EJB, 而是用POJO)</p>
<p>我下载了一本书<code>Beginning JSF™ 2 APIs and JBoss® Seam (Experts Voice in Java) (Kent Ka Iok Tong) (Z-Library).pdf</code>. 看了里面的示例, 看样子它在Server维护了一颗视图树, 走的是传统GUI的路子.</p>
<p>这是否有点像<strong>C# Blazor</strong>那套? 只不过Seam用的是Ajax, Blazor用的是更现代的Web Assembly或者WebSocket. 我靠.</p>
<h1 id="jboss社区别的项目"><a href="#jboss社区别的项目" class="headerlink" title="jboss社区别的项目"></a>jboss社区别的项目</h1><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>是个不错网络通讯的框架，如果你做手机socket通讯，建议你看看这个。</p>
<p>其实就是个事件驱动的Reactor框架.</p>
<h2 id="jgroups"><a href="#jgroups" class="headerlink" title="jgroups"></a>jgroups</h2><p>是个主要UDP通信的框架，如果你做局域网里的数据通讯建议你看看这个。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/jboss/" data-id="clesiwdla0001iwju3v9pa1b9" data-title="JBoss社区好的东西" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cond-variable" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/15/cond-variable/" class="article-date">
  <time class="dt-published" datetime="2023-01-15T09:37:17.391Z" itemprop="datePublished">2023-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/15/cond-variable/">对条件变量cv的思考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>请参看此篇文章(或者是教材某一章节):</p>
<p><a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf</a></p>
<p>现在要求父进程join子进程, 现在试图用cv来给出<code>thr_join</code>(父进程等待)和<code>thr_exit</code>(子进程宣告退出)的实现.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1 int done = 0;</span><br><span class="line">2 pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">3 pthread_cond_t c = PTHREAD_COND_INITIALIZER;</span><br><span class="line">4</span><br><span class="line">5 void thr_exit() &#123;</span><br><span class="line">6     Pthread_mutex_lock(&amp;m);</span><br><span class="line">7     done = 1;</span><br><span class="line">8     Pthread_cond_signal(&amp;c);</span><br><span class="line">9     Pthread_mutex_unlock(&amp;m);</span><br><span class="line">10 &#125;</span><br><span class="line">11</span><br><span class="line">12 void *child(void *arg) &#123;</span><br><span class="line">13     printf(&quot;child\n&quot;);</span><br><span class="line">14     thr_exit();</span><br><span class="line">15     return NULL;</span><br><span class="line">16 &#125;</span><br><span class="line">17</span><br><span class="line">18 void thr_join() &#123;</span><br><span class="line">19     Pthread_mutex_lock(&amp;m);</span><br><span class="line">20     while (done == 0)</span><br><span class="line">21         Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">22     Pthread_mutex_unlock(&amp;m);</span><br><span class="line">23 &#125;</span><br><span class="line">24</span><br><span class="line">25 int main(int argc, char *argv[]) &#123;</span><br><span class="line">26     printf(&quot;parent: begin\n&quot;);</span><br><span class="line">27     pthread_t p;</span><br><span class="line">28     Pthread_create(&amp;p, NULL, child, NULL);</span><br><span class="line">29     thr_join();</span><br><span class="line">30     printf(&quot;parent: end\n&quot;);</span><br><span class="line">31     return 0;</span><br><span class="line">32 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="形式化流程"><a href="#形式化流程" class="headerlink" title="形式化流程"></a>形式化流程</h2><p>令”读done”为(左←), 等为(下↓)<br>令”设done”为(右→), 踢为(上↑)</p>
<p>那么可以形式化描述带<code>lock(&amp;m)</code>的上述程序为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(←↓?)(→↑)</span><br></pre></td></tr></table></figure>

<p>问号?表示, 当且仅当<code>←</code>在<code>→</code>之前时, 取<code>↓</code>(如果done&#x3D;1, 事实上不用等了, 直接跳走就行)</p>
<h2 id="要点0-done变量的必要性"><a href="#要点0-done变量的必要性" class="headerlink" title="要点0: done变量的必要性"></a>要点0: done变量的必要性</h2><p>考虑上述形式化中, <code>(→↑)(←↓?)</code>的情形.</p>
<p><code>if(done)</code>正是判断↓是否执行的步骤.</p>
<p>如果没有此变量, 将发生<code>→↑←↓</code>. 这意味着”踢”被错过了, “等”发生在”踢”后.<br>故, 将会发生死锁现象, 没人会踢父进程了.</p>
<p>可见有<code>if(!done)</code>的逻辑, 是很有必要的. 至于这里我们采用<code>while(!done)</code>, 看似冗余, 其实也是必要的. 其原因, 下文的”要点3”有解释.</p>
<h2 id="要点1-mutex锁的必要性"><a href="#要点1-mutex锁的必要性" class="headerlink" title="要点1: mutex锁的必要性"></a>要点1: mutex锁的必要性</h2><p>需要注意的是, <code>lock(&amp;m)</code>是不可或缺的:</p>
<p>理由是: </p>
<p>根据形式化的式子, 现在, 有锁, 全体操作为2个原子操作, 即括号间不能重叠.</p>
<p>但取消锁, 操作就变成了4个原子操作. 其中, 括号内操作保序, 但不再原子.</p>
<p>于是, 考虑可能发生的<code>←→↑↓</code>的情形.</p>
<p>众所皆知, cv的踢, 仅当有东西等时才有效. 若没cv实例在等, 那么踢了什么都不会发生.</p>
<p>那么, 上述情形就成为了死锁: <code>thr_join</code>进程将不断等待.</p>
<h2 id="要点2-while的必要性"><a href="#要点2-while的必要性" class="headerlink" title="要点2: while的必要性"></a>要点2: while的必要性</h2><p>等的cv实例, 可能会被假唤醒(即明明没进程踢cv, 但操作系统却踢了你.)<br>其原理可能是: </p>
<p>其一, 不负责任的Solaris, 让它踢一个, 它会踢全部(参见维基英文词条”假唤醒”)</p>
<p>其二, 常见的操作系统行为, 此时确实有进程踢了, 但踢了后你的变量可能又被改了:</p>
<p>即, 确实有人踢了, 操作系统也正好打算唤醒被踢的人. 此时, 时间片到了, 另一个人又把done改了. 如果你不仅要考虑踢, 还要考虑done的正确性, 那么你需要while循环来检测.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/15/cond-variable/" data-id="clcx7fqa70000ysjubxnqgx2d" data-title="对条件变量cv的思考" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-coroutine-revisit" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/12/coroutine-revisit/" class="article-date">
  <time class="dt-published" datetime="2023-01-12T15:32:24.645Z" itemprop="datePublished">2023-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/12/coroutine-revisit/">重访coroutine</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>重访”协程”.</p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/coroutines">https://en.cppreference.com/w/cpp/language/coroutines</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">20计科一班肖嘉裕:</span><br><span class="line">比如: 协程是怎么恢复上下文的</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">比如一个没有initial_suspend的东西, 外界是怎么获得handle, 让它恢复执行的呢</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">还有就是, co_return后, 发生了什么?</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">&gt; 还有就是, co_return后, 发生了什么?</span><br><span class="line">这一点我想明白了, 应该是编译器自动塞了些保存线程上下文的代码, 把活儿给干了</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">&gt; 比如一个没有initial_suspend的东西, 外界是怎么获得handle, 让它恢复执行的呢</span><br><span class="line">这点的话, 我需要参考cppreference这个网站, 它有个生成器示例, 看看就知道handle在哪儿</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">我看了看, 发现handle是编译器自动注入promise_type的</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">handle有promise, done, destory, operator(), 这四种方法</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">可以自由控制协程的启停, 查询协程的状态, 获取协程的promise_type</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">cppreference里的Generator(也就是promise_type), 暴露了一个函数. 此函数可以调用handle的operator(), 让协程继续运行(也就是踢协程一脚)</span><br><span class="line"></span><br><span class="line">20计科一班肖嘉裕:</span><br><span class="line">这就是我的全部思路啦</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/12/coroutine-revisit/" data-id="clct926dx0000k0ju949mgq38" data-title="重访coroutine" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hexo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/11/hexo/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T16:21:47.179Z" itemprop="datePublished">2023-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/11/hexo/">Hexo参考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这些命令应该有所帮助:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo -h</span><br><span class="line">hexo d</span><br><span class="line">hexo g</span><br><span class="line">hexo d -g</span><br><span class="line"><span class="built_in">cat</span> (Get-PSReadlineOption).HistorySavePath | select-something hexo</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/11/hexo/" data-id="clcqfyx7e000138jubbh98da9" data-title="Hexo参考" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-haskell" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/11/haskell/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T16:18:36.886Z" itemprop="datePublished">2023-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/11/haskell/">Haskell配置笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>请注意: $PATH不要有win下的choco(cabal), 还有apt的ghc等等. 需要先清理干净.</p>
<h2 id="第一步-安装GHCUP"><a href="#第一步-安装GHCUP" class="headerlink" title="第一步, 安装GHCUP."></a>第一步, 安装GHCUP.</h2><p>(从官网上,找到curl安装脚本的链接.)</p>
<p>等它下完东西, ghcup就会出现在<del>&#x2F;.ghcup&#x2F;bin里面. 此时要在</del>&#x2F;.bashrc里重新export PATH&#x3D; $PATH:&#x2F;home&#x2F;turtle&#x2F;.ghcup&#x2F;bin.</p>
<p>装好后可以用tuna的hackage源, 把.cabal的config配置一下.</p>
<p>后续, 可以用ghcup tui, 把HLS之类的装上.</p>
<h2 id="第二步-创建cabal工程"><a href="#第二步-创建cabal工程" class="headerlink" title="第二步, 创建cabal工程."></a>第二步, 创建cabal工程.</h2><p>如: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir myvec &amp; cd myvec</span><br><span class="line">cabal init</span><br><span class="line">vim app/Main.hs</span><br><span class="line">vim app/Vec3.hs</span><br></pre></td></tr></table></figure>

<h2 id="第三步-显示指定hie-yaml"><a href="#第三步-显示指定hie-yaml" class="headerlink" title="第三步, 显示指定hie.yaml"></a>第三步, 显示指定hie.yaml</h2><p>根据<a target="_blank" rel="noopener" href="https://github.com/haskell/haskell-language-server/issues/2932">Multi Cradle: No prefixes </a><br>此issue, 不改hie.yaml, 就会:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Multi Cradle: No prefixes matched</span><br></pre></td></tr></table></figure>

<p>改法: </p>
<p>创建hie.yaml, 手动指定一些元信息. cabal留空, 因为它能自动推理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cradle:</span><br><span class="line">  cabal:</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cradle:</span><br><span class="line">  cabal:</span><br><span class="line">    - path: &quot;./src&quot;</span><br><span class="line">      component: &quot;exe:Main&quot;</span><br></pre></td></tr></table></figure>
<p>这样. 但这样太specific了. 不如上面自动推理</p>
<h2 id="第四步-改myvec-cabal"><a href="#第四步-改myvec-cabal" class="headerlink" title="第四步, 改myvec.cabal"></a>第四步, 改myvec.cabal</h2><p>受到<a target="_blank" rel="noopener" href="https://cabal.readthedocs.io/en/stable/cabal-package.html">6. Package Description</a>的启发:</p>
<p>把executable myvec加上<br><code>other-modules:    Vec3</code><br>这样你的Vec3.hs才是模块.否则就会</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">turtle@turtle:~/myvec$ cabal v2-repl /home/turtle/myvec/app/Vec3.hs</span><br><span class="line">cabal: Unknown target &#x27;/home/turtle/myvec/app/Vec3.hs&#x27;.</span><br><span class="line">The package myvec has no file target &#x27;app/Vec3.hs&#x27;.</span><br><span class="line"></span><br><span class="line">turtle@turtle:~/myvec$</span><br></pre></td></tr></table></figure>

<p>即:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Bug: `cabal repl file` fails for executable component</span><br></pre></td></tr></table></figure>

<h2 id="第五步-安装vscode-haskell插件"><a href="#第五步-安装vscode-haskell插件" class="headerlink" title="第五步, 安装vscode haskell插件"></a>第五步, 安装vscode haskell插件</h2><p>搜索安装插件,并且在settings.json里加上:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;haskell.manageHLS&quot;: &quot;GHCup&quot;,</span><br><span class="line">&quot;haskell.toolchain&quot;: &#123;</span><br><span class="line">    &quot;ghc&quot;: &quot;9.2.5&quot;,</span><br><span class="line">    &quot;hls&quot;: &quot;1.9.0.0&quot;,</span><br><span class="line">    &quot;cabal&quot;: &quot;recommended&quot;,</span><br><span class="line">    &quot;stack&quot;: null</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这些东西. 反正GHCup是可以在UI设置里调, 而且是必须调的(?)<br>而这个toolchain要不要调, 就不知道了. 照理说是按照cabal配置自动认的.</p>
<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>我手动编译了一个hls版本, 不知道有无影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghcup compile hls -v 1.9.0.0 --ghc 9.2.5</span><br></pre></td></tr></table></figure>

<p>编译它的动机是, 它总是说我用的ghc 8.6.5, 与它(hls)编译使用的ghc版本对不上.<br>我就手动编译了, 发现我使用的ghc还是8.6.5.</p>
<p>我就发现是apt的ghc, 在path里优先级较高, 导致它找apt的旧版本ghc去了.<br>而ghcup二进制下载来的prebuilt的hls, 版本貌似是对得上9.2.5的.<br>所以这个hls是白编译了.编译了挺久的, 大概1h.</p>
<h2 id="调试和测试说明"><a href="#调试和测试说明" class="headerlink" title="调试和测试说明"></a>调试和测试说明</h2><p>GHCi for Debug Intro</p>
<p><a target="_blank" rel="noopener" href="https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-debugger.html">https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-debugger.html</a></p>
<p>QuickCheck Intro</p>
<p><a target="_blank" rel="noopener" href="https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing">https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/11/haskell/" data-id="clcqfyx78000038jugp0sdck1" data-title="Haskell配置笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-coroutine" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/13/coroutine/" class="article-date">
  <time class="dt-published" datetime="2022-12-12T17:11:48.120Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/13/coroutine/">coroutine解剖麻雀</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>20计科一班肖嘉裕:<br>The io_service class does not manage any I&#x2F;O threads. You must ensure that some thread calls one of the event-processing methods for coroutines awaiting I&#x2F;O completion events to be dispatched.</p>
<p>20计科一班肖嘉裕:<br>io_service类不管理任何IO线程. (所以)你必须保证, 让某些线程去调用那些事件处理方法(指io_service.process_events()那四个方法), 这样来让某些await IO completion event的协程得到执行.</p>
<p>20计科一班肖嘉裕:<br>大体意思就是: 进入了ioScope后, 那个协程就废了, 除非有某些线程, 去await process_events(), 来让出线程, 帮那个IO协程跑.<br>(2023-01-12评论: 这是错的. 它的意思是: io_service是寄生虫, 需要某个线程去调用io_service_process_events(), 它才会在此寄生线程上工作. 等io_context的工作做完, 函数才返回.)</p>
<p>20计科一班肖嘉裕:<br>这是出自cppcoro官方仓库README文档, io_service部分</p>
<p>20计科一班肖嘉裕:<br>它说, 可以跟UI线程整合. 我的理解是: UI线程上跑了很多个协程. 应该专门划分新IO线程, 专门给IO跑, 免得UI线程上放了个IO的协程, 导致其他很多UI协程都执行不了了.<br>(评论: 这是错的. 其实是这样理解: 如QT, 它每次事件循环, 会提供一个信号. 你可以创建槽函数, 槽里调用”io_context.poll_one_event()”, 再把此槽连接到那信号. 就完成了集成.)</p>
<p>请看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 这是计网实验(聊天室)的头文件. 这只是从GitHub的</span></span><br><span class="line"><span class="comment">// CoChat拷贝来的源码. 这是当时抄Stack Overflow所得到的</span></span><br><span class="line"><span class="comment">// 勉强能用的实现.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file co.hpp</span></span><br><span class="line"><span class="comment"> * @author turtle (qq769711153@hotmail.com)</span></span><br><span class="line"><span class="comment"> * @brief Header for Enabling C++20 Coroutine Support</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-06-18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Enable the use of std::future&lt;T&gt; as a coroutine type</span></span><br><span class="line"> <span class="comment">// by using a std::promise&lt;T&gt; as the promise type.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="built_in">requires</span>(!std::is_void_v&lt;T&gt; &amp;&amp; !std::is_reference_v&lt;T&gt;)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::coroutine_traits&lt;std::future&lt;T&gt;, Args...&gt; &#123;</span><br><span class="line">    <span class="comment">// future还不能作为coroutine type</span></span><br><span class="line">    <span class="comment">// 有两个解决办法: </span></span><br><span class="line">    <span class="comment">// 1. 新弄一个class, 里面需要定义struct promise_type(要么是内部类, 要么是typedef)</span></span><br><span class="line">    <span class="comment">// 2. 对于future&lt;T&gt;, 写一个coroutine_traits, 里面放一个promise_type, 好好进行指定.</span></span><br><span class="line">    <span class="comment">// 所以就有了这个东西.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> : std::promise&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 当你: auto a = fCoro();的时候, a就是丢给你这个东西的.</span></span><br><span class="line">        <span class="comment">// 本质上可以丢给你handle, 但这里, 是丢给你与promise伴随的future. promise是一个空箱子, </span></span><br><span class="line">        <span class="comment">// 只要你往里面塞一个值, 那么箱子里就有东西了. 对应的future就能get到东西了.</span></span><br><span class="line">        <span class="function">std::future&lt;T&gt; <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这很简单, 即调用fCoro()的时候, 里面该不该多暂停一次. 还有退出的时候该不该多暂停一次.</span></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这指定了co_return的行为. 从此处看来, 发生的事情是, promise被塞了东西(随之, 上述的伴随future也能get了)</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">            <span class="title">noexcept</span><span class="params">(std::is_nothrow_copy_constructible_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_value</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(T&amp;&amp; value)</span></span></span><br><span class="line"><span class="function">            <span class="title">noexcept</span><span class="params">(std::is_nothrow_move_constructible_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_value</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same for std::future&lt;void&gt;.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::coroutine_traits&lt;std::future&lt;<span class="type">void</span>&gt;, Args...&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> : std::promise&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow co_await&#x27;ing std::future&lt;T&gt; and std::future&lt;void&gt;</span></span><br><span class="line"><span class="comment">// by naively spawning a new thread for each co_await.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">(std::future&lt;T&gt; future)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    <span class="title">requires</span><span class="params">(!std::is_reference_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是指定co_await操作符的行为.可见这里指定的是, 操作数为future&lt;T&gt;时, 会发生什么</span></span><br><span class="line">    <span class="comment">// 总之, 操作符需要返回一个带有三个特殊方法(await_ready, await_suspend, await_resume)的类实例.</span></span><br><span class="line">    <span class="comment">// 运行的时候, 执行这个操作符之后, 会发生这样的事情:</span></span><br><span class="line">    <span class="comment">// 首先, 调用await_ready, 如果ready了, 直接调用await_resume, 否则, 就调用await_suspend(此时还会把handle塞给你).</span></span><br><span class="line">    <span class="comment">// 我的理解是: resume的话, coroutine在这个线程上继续跑. 否则(即suspend), 它就会让出当前线程, 并且handle.resume()在哪个线程执行,</span></span><br><span class="line">    <span class="comment">// coroutine就会在哪个线程上接着跑.</span></span><br><span class="line">    <span class="comment">// 剩下的, 运行时啥都不会干了. 所以全凭你往这三个函数里塞了什么.</span></span><br><span class="line">    <span class="comment">// 请看这个示例, 以下是执行的代码:</span></span><br><span class="line">    <span class="comment">// fa()&#123;</span></span><br><span class="line">    <span class="comment">//     x = await xx;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// fb()&#123;</span></span><br><span class="line">    <span class="comment">//     y = await yy;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// auto a = fa();</span></span><br><span class="line">    <span class="comment">// auto b = fb();</span></span><br><span class="line">    <span class="comment">// 同时, 在await操作符的配置中有:</span></span><br><span class="line">    <span class="comment">// await_suspend(handle)&#123;</span></span><br><span class="line">    <span class="comment">//     newthread([]&#123;</span></span><br><span class="line">    <span class="comment">//         handle(); // 即继续运行协程. 即又来到await_ready这里. 此时会ready, 接下来调用await_resume, </span></span><br><span class="line">    <span class="comment">//                   // 当此resume函数返回值后, 协程就又跑起来了.</span></span><br><span class="line">    <span class="comment">//     &#125;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 那么, 考虑上述那两段代码, 运行后会发生这些事情:</span></span><br><span class="line">    <span class="comment">// 现在, 在主线程上. 先执行fa(), 此时有coroutine_traits的promise_type配置, 它的get_return_object会随便给你些什么东西.</span></span><br><span class="line">    <span class="comment">// 现在, 主线程在跑fa了. 跑到await那行, 求值xx, 然后进入await操作符的函数. 它发现不ready, 得suspend. 于是进入awaiter的</span></span><br><span class="line">    <span class="comment">// suspend. 在这里, 我们开了个新线程, 然后用handle(), 踢了协程a一脚. 注意, handle是在新线程上执行的. 于是新线程上开始跑await_ready,</span></span><br><span class="line">    <span class="comment">// 此时ready了, 很好, 执行await_resume. resume函数返回了个值, 之后会赋给await左边的东西. 当resume函数返回完毕, 协程a也随之在新线程上</span></span><br><span class="line">    <span class="comment">// 继续跑了起来.</span></span><br><span class="line">    <span class="comment">// 而此时, 旧线程上, await_suspend成功返回. 那么现在旧线程已经没在跑别的东西了. 于是, 开始执行fb()又重复上述过程, 这下, 协程b也在另一个</span></span><br><span class="line">    <span class="comment">// 新线程上跑起来了.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">awaiter</span> : std::future&lt;T&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">wait_for</span>(<span class="number">0</span>s) != std::future_status::timeout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; cont)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 注意这里传入了handle</span></span><br><span class="line">            std::<span class="built_in">thread</span>([<span class="keyword">this</span>, cont] &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">wait</span>();</span><br><span class="line">            <span class="built_in">cont</span>();</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> awaiter&#123; std::<span class="built_in">move</span>(future) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // Utilize the infrastructure we have established.</span></span><br><span class="line"><span class="comment">// std::future&lt;int&gt; compute(as_coroutine) &#123;</span></span><br><span class="line"><span class="comment">//     int a = co_await std::async([] &#123; std::cout &lt;&lt; &quot;six\n&quot;; return 6; &#125;);</span></span><br><span class="line"><span class="comment">//     int b = co_await std::async([] &#123; std::cout &lt;&lt; &quot;seven\n&quot;; return 7; &#125;);</span></span><br><span class="line"><span class="comment">//     co_return a * b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::future&lt;void&gt; fail(as_coroutine) &#123;</span></span><br><span class="line"><span class="comment">//     throw std::runtime_error(&quot;bleah&quot;);</span></span><br><span class="line"><span class="comment">//     co_return;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int tach() &#123;</span></span><br><span class="line"><span class="comment">//     auto fut = compute(&#123;&#125;);</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; fut.get();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/13/coroutine/" data-id="clbl203rw0000gkjuddlb3fxk" data-title="coroutine解剖麻雀" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-opengl" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/12/opengl/" class="article-date">
  <time class="dt-published" datetime="2022-12-12T07:47:35.105Z" itemprop="datePublished">2022-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/12/opengl/">OpenGL各种东西详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="glut-freeglut-glfw"><a href="#glut-freeglut-glfw" class="headerlink" title="glut, freeglut, glfw"></a>glut, freeglut, glfw</h1><ol>
<li>glut<ul>
<li>gl util tools</li>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘和鼠标事件</li>
<li>以一个函数呼叫绘制某些常用立体图形,如长方体,球,犹他茶壶</li>
<li>提供了简单选单列的实现</li>
</ul>
</li>
</ol>
<p>所有glut的库函数均已glut开头, 例如glutPostRedisplay(). 后来以及停止维护了</p>
<ol start="2">
<li><p>freeglut<br> glut的替代品,最新稳定的版本是Freeglut3.0.0 (2015年3月7日)</p>
</li>
<li><p>glfw</p>
<ul>
<li>gl framework</li>
<li>创建管理窗口和opengl的上下文</li>
<li>处理手柄,键盘,鼠标输入</li>
<li>目前glfw还在维护,可以说glfw库可以是代替glut和freeglut的库的</li>
</ul>
</li>
</ol>
<h1 id="glew-glad-gl3w"><a href="#glew-glad-gl3w" class="headerlink" title="glew, glad, gl3w"></a>glew, glad, gl3w</h1><p>opengl是一个标准&#x2F;规范, 具体的实现是由驱动开发商针对特定的显卡而实现.支持opengl的驱动版本众多,大多数函数的地址(内存地址)无法在编译时候确定下来,需要运行的时候查询.所以在运行的时候获取函数的内存地址并把其保存在一个函数指针中供后续使用. glew, glad, gl3w基本都是实现类似的功能</p>
<p>glew,<br>    opengl32.dll仅仅为用户提供了统一API的接口以及扩展这些接口的可能, opengl32.dll被加载后尝试调用更底层的ICD驱动程序,从而完成具体的图形操作. 而GLEW这些库,根据opengl的接口说明,从动态库(opengl32.dll)中请求对应的函数接口,如果能得到有效地址,那么这个函数是被当前驱动所支持的,就可以用,否则就无法支持.实际上,你也可以根据你当前应用中使用到的函数(通常一个小的演示demo,如显示一个三角形,并没有使用到很多的gl函数)而获取函数接口也是完全可行的. glew,glad,gl3w这些库帮助用户完成了所有接口的查询和获取.</p>
<p>glad,<br>gl3w</p>
<p>但是gl3w是利用python开发的, 因此需要安装python库进行编译生成相关的文件,具体的流程可以参考<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/jiuzaizuotian2014/article/details/82915917">基于GLFW和GL3W库的OPEN GL环境配置</a></p>
<p>结论: 可以用上面两类的库进行组合,例如我自己常用的是glfw + glad来进行opengl的开发, 也有很多开发者使用的是glfw + gl3w, 或者 glfw + glew</p>
<h1 id="另一篇说的"><a href="#另一篇说的" class="headerlink" title="另一篇说的"></a>另一篇说的</h1><p>opengl原生库?<strong>gl</strong></p>
<p>随opengl一起发布</p>
<p>opengl实用库?<strong>glu</strong><br>随opengl一起发布</p>
<p>opengl实用工具库glut?<strong>glut</strong><br>需要下载配置安装(太老了！)</p>
<p>opengl实用工具库开源版本freeglut?<strong>freeglut</strong><br>需要下载配置安装(完全兼容glut，算是glut的代替品，但是bug较多！)</p>
<p>opengl GLFW库?<strong>glfw</strong><br>需要下载配置安装(轻量级的，开源的，跨平台的library，新技术)</p>
<p>opengl GLEW库?<strong>glew</strong><br>需要下载配置安装<br>跨平台的C++扩展库，它的出现是为了方便的管理平台与opengl版本不匹配，以及方便的解决不同显卡特有的硬件接口支持。<br>只要包含一个glew.h头文件，你就能使用gl,glu,glext,wgl,glx的全部函数。</p>
<p>opengl核心文件加载库gl3w?<strong>gl3w</strong><br>gl3w是获取OpenGL核心配置文件规范所提供功能的最简单方法。</p>
<p>opengl库glad?<strong>glad</strong><br>基于官方规格的多语言GL &#x2F; GLES &#x2F; EGL &#x2F; GLX &#x2F; WGL装载机 - 生成器。<br>一般结合GLFW使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gl</td>
<td>核心库</td>
<td>随opengl一起发布. 貌似只是规范, 里面的函数只是签名, 没有链接?</td>
</tr>
<tr>
<td>glu</td>
<td>实用工具</td>
<td>随opengl一起发布</td>
</tr>
<tr>
<td>glut</td>
<td>很老的util</td>
<td>貌似是glfw+glew?20年没维护, 建议别用</td>
</tr>
<tr>
<td>freeglut</td>
<td>没那么老的util</td>
<td>glut继任者, 貌似也废了</td>
</tr>
<tr>
<td>glfw</td>
<td>靠谱的util, 即framework</td>
<td>帮你得到Window和OpenGL Rendering Context</td>
</tr>
<tr>
<td>glew</td>
<td>OpenGL Extension Wrangler</td>
<td>即,把显卡驱动里写好的dll嫁接到glew的函数指针上</td>
</tr>
<tr>
<td>gl3w</td>
<td>同上</td>
<td>这貌似用Python写的</td>
</tr>
<tr>
<td>glad</td>
<td>同上</td>
<td></td>
</tr>
</tbody></table>
<p>glfw is:</p>
<p><em>a library that helps you to manage such things as window, its size, params, basic input and events-stuff. GLEW needs a window and a valid OpenGL context to be setup, and that’s exactly where GLFW comes in handy.</em></p>
<p>glfw is:<br><em>Open source, portable framework for OpenGL application development with a link library for handling operating system specific tasks, such as opening an OpenGL window and reading keyboard, mouse and joystick input.</em></p>
<p>What is also interesting that these libraries were made not just to make your developing life easier, but also your <strong>deployment faster</strong>. GLEW and GLFW are kind of cross-platform so you don’t have to write different versions of the same application on different platforms.</p>
<p>As practice shows, GLEW&#x2F;GLAD + GLFW is a common use for modern computer graphics based on OpenGL. You?<em>could</em>, however, choose other libraries for a reason, based on what you need. But the general approach is to use these, because they support the latest versions of OpenGL, and always get updated.</p>
<p>EDIT</p>
<p>GLUT and GLFW are basically the same, but what you need to know is that the original GLUT has been unsupported for 20 years, and there is a free open-source alternative for it called freeglut. So, I guess that is what you mean by “deprecated” :)</p>
<p>COMMENT</p>
<p>GLFW purpose is to manage OpenGL contexts and basics of window-, keyboard-, event-handling. </p>
<p>It does not do automatic extension loading, so without a loader like glad, you can only use what the system provides on its own (which could also be the current version). </p>
<p>But you can load extensions&#x2F;functions manually using GLFW, so you indeed could use modern OpenGL using only GLFW.</p>
<p>COMMENT</p>
<p>OpenGL is already developed by the GPU manufacturers, saved as binary file in the graphics drive. </p>
<p>You can use it without any additional libraries. However, this would be complicated, especially for unexperienced developers. </p>
<p>For simplification, you can use any opengl loader library (<code>FreeGlut, Glad, Glew, GLUT</code>) + for windowing can use?<code>GLFW</code>. GLUT is often not recommended, and?<code>FreeGLUT</code>?and?<code>GLEW</code>?are widely used. You can use?<code>microsoft vcpkg</code>?to install these libraries.</p>
<h1 id="没glut-glew怎么套到现代函数"><a href="#没glut-glew怎么套到现代函数" class="headerlink" title="没glut glew怎么套到现代函数?"></a>没glut glew怎么套到现代函数?</h1><p><a target="_blank" rel="noopener" href="https://mariuszbartosik.com/opengl-4-x-initialization-in-windows-without-a-framework/">OpenGL 4.x Initialization in Windows without a Framework (mariuszbartosik.com)</a></p>
<p>怎么不用glut和glew, 空手套到现代OpenGL高版本函数.</p>
<p>首先, XP之后, 即Vista开始, 由于API之争, 微软的WindowsSDK只给你OpenGL1.1的gl.h. 但它的opengl32.dll给你一个wglGetProcAddress()方法, 可以用来套那些高版本OpenGL函数.</p>
<p>但这个wglGetProcAddress()需要一个OpenGL rendering context. 这就需要想想办法.</p>
<p>正常情况, 你通过<code>GetDC()</code>获得Device Context, 然后, pick a hardware accelerated pixel format with?<code>ChoosePixelFormat()</code>?and associate it with Device Context using?<code>SetPixelFormat()</code>. Then you can create Rendering Context with?<code>wglCreateContext()</code>?and set it as current with?<code>wglMakeCurrent()</code>. Load new OpenGL functions with?<code>wglGetProcAddress()</code>?and you are ready to use them.</p>
<p>The problem with old?<code>ChoosePixelFormat()</code>?and?<code>wglCreateContext()</code>?is that they are not extensible. For example, the first one uses fixed?<code>PIXELFORMATDESCRIPTOR</code>?structure and there is no field you could set to indicate that you want to request multisampling, sRGB format or floating-point framebuffer support. Using the later one, you cannot ask for specific OpenGL profile or version.</p>
<p>To remedy this, new functions have been created, namely?<code>wglChoosePixelFormatARB()</code>?and?<code>wglCreateContextAttribsARB()</code>. Both of them accepts lists of attributes, so they can support any number of options. There is a small problem, though. To create a rendering context using them, you have to get their function pointers, and for this, you need a rendering context.</p>
<p>Luckily, this can be solved by creating a dummy window and context with old functions, getting new function pointers and creating window and context in the desired format.</p>
<p>接下来就是一波操作. 首先先拉个旧窗口, 用<code>PIXELFORMATDESCRIPTOR</code>随便糊个窗口, 然后用那些ARB函数, 设置PixelFormat, 弄出个能用的Rendering COntext. 最后用这个Context去套OpenGL函数.</p>
<p>现在, 引入OpenGL委员会给的高版本头文件, 你就能把套来的函数地址, 绑到它给的签名上去用了!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/12/opengl/" data-id="clbkhsitc0000lsju3gd649eg" data-title="OpenGL各种东西详解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/OpenGL/" style="font-size: 10px;">OpenGL</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/haskell/" style="font-size: 10px;">haskell</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%9D%82%E6%84%9F/" style="font-size: 20px;">杂感</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 15px;">编码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/03/ime-research/">Win10控制台应用IME研究</a>
          </li>
        
          <li>
            <a href="/2023/03/03/encoding/">字符编码的历史与dotnet的做法</a>
          </li>
        
          <li>
            <a href="/2023/03/03/saga-agenda/">YouTube Saga视频的Agenda</a>
          </li>
        
          <li>
            <a href="/2023/03/03/jboss/">JBoss社区好的东西</a>
          </li>
        
          <li>
            <a href="/2023/01/15/cond-variable/">对条件变量cv的思考</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Master Turtle<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>